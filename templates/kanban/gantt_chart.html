{% extends 'base.html' %}
{% load static kanban_filters %}

{% block title %}{{ board.name }} - Gantt Chart{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.css">
<style>
    /* ============================================
       PROFESSIONAL GANTT CHART STYLES
       ============================================ */
    
    .gantt-container {
        padding: 24px;
        background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        margin: 20px 0;
        overflow-x: auto;
        border: 1px solid #e2e8f0;
    }

    .gantt-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        flex-wrap: wrap;
        gap: 16px;
        padding-bottom: 16px;
        border-bottom: 2px solid #e2e8f0;
    }

    .gantt-header h2 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 600;
        color: #1e293b;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    /* ============================================
       PROFESSIONAL DEPENDENCY ARROWS
       ============================================ */

    /* Hide ALL default frappe-gantt arrow polygons (they appear as distorted Y-shapes) 
       Use multiple selectors and maximum specificity to override inline styles */
    .gantt polygon:not(.milestone-diamond-shape):not(.custom-arrowhead),
    .gantt g.arrow polygon,
    .gantt .arrow polygon,
    svg#gantt polygon:not(.milestone-diamond-shape):not(.custom-arrowhead) {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        width: 0 !important;
        height: 0 !important;
        transform: scale(0) !important;
    }

    /* But show polygons inside our custom markers (defs) */
    .gantt defs marker polygon,
    .gantt defs marker polygon.custom-arrowhead,
    svg#gantt defs marker polygon {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        width: auto !important;
        height: auto !important;
        transform: none !important;
    }

    /* Main arrow path styling - clean, consistent look */
    .gantt .arrow,
    .gantt path.arrow,
    .gantt g.arrow path,
    svg#gantt g.arrow path {
        fill: none !important;
        stroke: #64748b !important;
        stroke-width: 2px !important;
        stroke-linecap: round !important;
        stroke-linejoin: round !important;
        opacity: 0.8 !important;
        marker-end: url(#arrowhead-custom) !important;
    }

    .gantt .arrow:hover,
    .gantt path.arrow:hover,
    .gantt g.arrow path:hover {
        stroke: #3b82f6 !important;
        stroke-width: 2.5px !important;
        opacity: 1 !important;
    }

    /* ============================================
       VIEW MODE BUTTONS
       ============================================ */

    .view-buttons {
        display: flex;
        gap: 4px;
        background: #f1f5f9;
        padding: 4px;
        border-radius: 8px;
    }

    .view-buttons button {
        padding: 10px 20px;
        border: none;
        background: transparent;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        color: #64748b;
        font-size: 0.875rem;
    }

    .view-buttons button:hover {
        background: #e2e8f0;
        color: #334155;
    }

    .view-buttons button.active {
        background: #3b82f6;
        color: white;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    /* ============================================
       TASK BAR PRIORITY COLORS
       ============================================ */

    .gantt .bar-wrapper .bar[data-priority="low"] {
        fill: #94a3b8 !important;
        rx: 6;
        ry: 6;
    }

    .gantt .bar-wrapper .bar[data-priority="medium"] {
        fill: #3b82f6 !important;
        rx: 6;
        ry: 6;
    }

    .gantt .bar-wrapper .bar[data-priority="high"] {
        fill: #f59e0b !important;
        rx: 6;
        ry: 6;
    }

    .gantt .bar-wrapper .bar[data-priority="urgent"] {
        fill: #ef4444 !important;
        rx: 6;
        ry: 6;
    }

    /* ============================================
       MILESTONE STYLING - GLOWING DIAMOND EFFECT
       ============================================ */

    /* Animation for milestone glowing pulsing effect */
    @keyframes milestonePulse {
        0%, 100% {
            filter: drop-shadow(0 0 4px rgba(124, 58, 237, 0.7)) drop-shadow(0 0 8px rgba(124, 58, 237, 0.5));
        }
        50% {
            filter: drop-shadow(0 0 10px rgba(124, 58, 237, 1)) drop-shadow(0 0 20px rgba(124, 58, 237, 0.7));
        }
    }

    /* Milestone bar - purple color with continuous glow */
    .gantt .bar-wrapper .bar[data-is-milestone="true"],
    .gantt .bar-wrapper .bar[data-is-milestone="true"][data-priority="low"],
    .gantt .bar-wrapper .bar[data-is-milestone="true"][data-priority="medium"],
    .gantt .bar-wrapper .bar[data-is-milestone="true"][data-priority="high"],
    .gantt .bar-wrapper .bar[data-is-milestone="true"][data-priority="urgent"] {
        fill: #7c3aed !important;
        stroke: #5b21b6 !important;
        stroke-width: 2.5px !important;
        rx: 4 !important;
        ry: 4 !important;
        animation: milestonePulse 2.4s ease-in-out infinite !important;
    }

    .gantt .bar-wrapper .bar[data-is-milestone="true"]:hover {
        fill: #6d28d9 !important;
        animation: none !important;
        filter: brightness(1.2) drop-shadow(0 0 14px rgba(124, 58, 237, 0.9)) !important;
    }

    /* Milestone completed variant - green to indicate done */
    .gantt .bar-wrapper .bar[data-is-milestone="true"][data-milestone-status="completed"] {
        fill: #047857 !important;
        stroke: #064e3b !important;
        animation: milestonePulse 3s ease-in-out infinite !important;
    }

    /* Diamond shape overlay on milestone bars */
    .milestone-diamond-shape {
        pointer-events: none;
    }

    /* ============================================
       CRITICAL PATH STYLING - HIGH SPECIFICITY
       ============================================ */

    /* Animation for critical path pulsing effect */
    @keyframes criticalPathPulse {
        0%, 100% {
            filter: drop-shadow(0 0 4px rgba(220, 38, 38, 0.6)) drop-shadow(0 0 8px rgba(220, 38, 38, 0.4));
        }
        50% {
            filter: drop-shadow(0 0 8px rgba(220, 38, 38, 0.9)) drop-shadow(0 0 16px rgba(220, 38, 38, 0.6));
        }
    }

    /* Critical path tasks - MUST override priority colors */
    /* Using higher specificity selectors */
    .gantt .bar-wrapper .bar[data-critical-path="true"],
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="low"],
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="medium"],
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="high"],
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="urgent"] {
        fill: #dc2626 !important;
        stroke: #7f1d1d !important;
        stroke-width: 3px !important;
        animation: criticalPathPulse 2s ease-in-out infinite !important;
    }

    .gantt .bar-wrapper .bar[data-critical-path="true"]:hover,
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="low"]:hover,
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="medium"]:hover,
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="high"]:hover,
    .gantt .bar-wrapper .bar[data-critical-path="true"][data-priority="urgent"]:hover {
        fill: #b91c1c !important;
        animation: none !important;
        filter: brightness(1.15) drop-shadow(0 0 12px rgba(220, 38, 38, 0.8)) !important;
    }

    /* Critical path toggle control */
    .critical-path-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        border: 1px solid #fecaca;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
    }

    .critical-path-toggle:hover {
        background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
        border-color: #f87171;
    }

    .critical-path-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: #dc2626;
        cursor: pointer;
    }

    .critical-path-toggle label {
        font-size: 0.875rem;
        font-weight: 500;
        color: #991b1b;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .critical-path-toggle .cp-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #dc2626;
        border-radius: 3px;
        border: 1px solid #991b1b;
    }

    /* Hide progress overlay for cleaner look */
    .gantt .bar-wrapper .bar-progress {
        display: none !important;
    }

    /* Ensure bars have uniform color and rounded corners */
    .gantt .bar-wrapper .bar {
        opacity: 1 !important;
        rx: 6;
        ry: 6;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        transition: all 0.2s ease;
    }
    
    /* Month view: enhance bar visibility with stronger shadows and borders */
    body[data-view-mode="Month"] .gantt .bar-wrapper .bar {
        filter: drop-shadow(0 3px 6px rgba(0,0,0,0.15));
        stroke: rgba(255, 255, 255, 0.3);
        stroke-width: 1;
        /* Ensure minimum visual weight for bars in month view */
        min-width: 4px !important;
    }
    
    body[data-view-mode="Month"] .gantt .bar-wrapper:hover .bar {
        filter: brightness(1.15) drop-shadow(0 5px 10px rgba(0,0,0,0.25));
        stroke-width: 2;
    }

    /* Make bars clearly clickable with hover effects */
    .gantt .bar-wrapper {
        cursor: pointer !important;
    }

    .gantt .bar-wrapper:hover .bar {
        filter: brightness(1.15) drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        transform: translateY(-1px);
    }

    /* Hide resize handles - they're misleading since drag is disabled */
    .gantt .handle,
    .gantt .bar-handle,
    .gantt .handle.left,
    .gantt .handle.right,
    .gantt .bar-wrapper .handle,
    rect.handle {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
    }

    /* Remove resize cursor on bar edges */
    .gantt .bar-wrapper:hover {
        cursor: pointer !important;
    }
    
    .gantt .bar:hover {
        cursor: pointer !important;
    }

    /* Empty state styling */
    .empty-state {
        text-align: center;
        padding: 80px 20px;
        color: #64748b;
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-radius: 12px;
        border: 2px dashed #cbd5e1;
    }

    .empty-state i {
        font-size: 4rem;
        margin-bottom: 24px;
        opacity: 0.4;
        color: #94a3b8;
    }

    .empty-state h3 {
        color: #475569;
        margin-bottom: 12px;
    }

    /* Board navigation tabs */
    .board-tabs {
        margin-bottom: 20px;
        border-bottom: 2px solid #e2e8f0;
    }

    .board-tabs .nav-link {
        color: #64748b;
        border: none;
        border-bottom: 3px solid transparent;
        padding: 0.75rem 1.25rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .board-tabs .nav-link:hover {
        color: #3b82f6;
        border-bottom-color: #bfdbfe;
    }

    .board-tabs .nav-link.active {
        color: #3b82f6;
        border-bottom-color: #3b82f6;
        background: none;
    }

    /* ============================================
       PROFESSIONAL LEGEND
       ============================================ */

    .gantt-legend {
        margin-top: 24px;
        padding: 16px 20px;
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 24px;
    }

    .gantt-legend strong {
        color: #475569;
        font-size: 0.875rem;
        margin-right: 8px;
    }

    .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.875rem;
        color: #64748b;
    }

    .legend-color {
        display: inline-block;
        width: 24px;
        height: 12px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }

    /* ============================================
       TASK BAR LABELS
       ============================================ */

    .gantt .bar-label {
        font-size: 11px;
        font-weight: 600;
        fill: white !important;
        text-shadow: 0 1px 3px rgba(0,0,0,0.4);
        pointer-events: none;
        text-anchor: middle !important;
        dominant-baseline: middle !important;
        letter-spacing: 0.02em;
    }
    
    /* Month view: increase label font size for better readability */
    body[data-view-mode="Month"] .gantt .bar-label {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 4px rgba(0,0,0,0.5);
    }

    .gantt .bar-label.outside-left,
    .gantt .bar-label.outside-right {
        fill: white !important;
        text-shadow: 0 1px 3px rgba(0,0,0,0.4) !important;
        font-weight: 600;
    }

    /* Task bar info overlay */
    .bar-info-overlay {
        pointer-events: none;
        font-size: 11px;
        fill: rgba(255, 255, 255, 0.95);
        font-weight: 600;
    }

    .assignee-avatar {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: white;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        color: #374151;
        border: 2px solid rgba(255,255,255,0.3);
        position: absolute;
        right: 4px;
        top: 50%;
        transform: translateY(-50%);
    }

    /* ============================================
       PROFESSIONAL TOOLTIP
       ============================================ */

    .gantt-tooltip {
        position: fixed;
        background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
        color: white;
        padding: 12px 16px;
        border-radius: 10px;
        font-size: 13px;
        pointer-events: none;
        z-index: 1000;
        white-space: nowrap;
        box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        display: none;
        border: 1px solid rgba(255,255,255,0.1);
        max-width: 320px;
    }

    .gantt-tooltip.show {
        display: block;
        animation: tooltipFadeIn 0.15s ease-out;
    }

    @keyframes tooltipFadeIn {
        from {
            opacity: 0;
            transform: translateY(4px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .gantt-tooltip strong {
        color: #f8fafc;
        display: block;
        margin-bottom: 6px;
        font-size: 14px;
    }

    .gantt-tooltip .tooltip-row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin: 4px 0;
        color: #cbd5e1;
        font-size: 12px;
    }

    .gantt-tooltip .tooltip-row i {
        width: 14px;
        color: #94a3b8;
    }

    /* ============================================
       GANTT GRID AND TIMELINE STYLING
       ============================================ */

    .gantt .grid-header {
        fill: #f8fafc;
        stroke: #e2e8f0;
    }

    .gantt .grid-row {
        fill: transparent;
    }

    .gantt .grid-row:nth-child(even) {
        fill: rgba(241, 245, 249, 0.5);
    }

    .gantt .row-line {
        stroke: #e2e8f0;
    }

    .gantt .tick {
        stroke: #e2e8f0;
        stroke-width: 1;
    }

    .gantt .today-highlight {
        fill: rgba(59, 130, 246, 0.08);
        stroke: #3b82f6;
        stroke-width: 2;
        stroke-dasharray: 4, 4;
    }

    .gantt .lower-text, .gantt .upper-text {
        fill: #64748b;
        font-weight: 500;
        font-size: 12px;
    }

    .gantt .upper-text {
        fill: #475569;
        font-weight: 600;
    }
    
    /* Month view: enhance grid text visibility */
    body[data-view-mode="Month"] .gantt .lower-text,
    body[data-view-mode="Month"] .gantt .upper-text {
        font-weight: 600;
        font-size: 13px;
    }

    /* ============================================
       DEPENDENCY ARROW ENHANCEMENTS
       ============================================ */

    /* Ensure all arrow heads (markers) are hidden except our custom one */
    .gantt marker polygon {
        display: block !important;
    }



    /* ============================================
       ASSIGNEE INITIALS ON TASK BARS
       ============================================ */

    .assignee-initials {
        font-size: 10px;
        font-weight: 700;
        fill: white;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .assignee-circle {
        fill: rgba(255, 255, 255, 0.25);
        stroke: rgba(255, 255, 255, 0.4);
        stroke-width: 1;
    }

    /* ============================================
       PHASE-BASED VIEW STYLES
       ============================================ */

    .phase-view-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
    }

    .phase-view-controls .btn {
        transition: all 0.2s ease;
    }

    .phase-view-controls .btn.active {
        background: #3b82f6;
        border-color: #3b82f6;
        color: white;
    }

    /* Phase bar styling */
    .gantt .bar-wrapper .bar[data-is-phase="true"] {
        fill: #6366f1 !important;
        rx: 8;
        ry: 8;
        cursor: pointer;
        filter: drop-shadow(0 3px 6px rgba(99, 102, 241, 0.3));
    }

    .gantt .bar-wrapper .bar[data-is-phase="true"]:hover {
        filter: brightness(1.1) drop-shadow(0 4px 8px rgba(99, 102, 241, 0.4));
    }

    /* Phase expanded state */
    .gantt .bar-wrapper .bar[data-is-phase="true"][data-expanded="true"] {
        fill: #4f46e5 !important;
    }

    /* IMPORTANT: Default blue color for ALL bars to prevent grey flash */
    /* Priority colors below use !important and will override this for tasks */
    /* Phase bars without data-priority will remain blue (phase-1, phase-2, etc.) */
    .gantt .bar-wrapper .bar:not([data-priority]) {
        fill: #6366f1 !important;
    }

    /* Gantt chart wrapper - hide until chart is ready to prevent shrink/expand animation */
    #gantt-chart-wrapper {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    #gantt-chart-wrapper.chart-ready {
        opacity: 1;
    }
    
    /* While transitioning views, keep the wrapper visible but prevent flash */
    #gantt-chart-wrapper.transitioning {
        opacity: 1;
    }
    
    /* Ensure bars inside transitioning wrapper maintain their colors */
    #gantt-chart-wrapper.transitioning .gantt .bar-wrapper .bar:not([data-priority]) {
        fill: #6366f1 !important;
    }

    /* Phase collapse indicator */
    .phase-indicator {
        font-size: 0.75rem;
        padding: 2px 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        margin-left: 8px;
    }

    /* Phase info panel */
    .phase-info-panel {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
    }

    .phase-info-panel .phase-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 4px;
        background: white;
        border-radius: 6px;
        border: 1px solid #e2e8f0;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .phase-info-panel .phase-item:hover {
        background: #f1f5f9;
        border-color: #cbd5e1;
    }

    .phase-info-panel .phase-item.expanded {
        background: #eff6ff;
        border-color: #3b82f6;
    }

    .phase-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 0.75rem;
        padding: 2px 8px;
        border-radius: 4px;
    }

    .phase-badge.tasks {
        background: #dbeafe;
        color: #1d4ed8;
    }

    .phase-badge.milestones {
        background: #fef3c7;
        color: #b45309;
    }

    /* ============================================
       GANTT SEARCH & FILTER STYLES
       ============================================ */

    .gantt-filters {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
        padding: 16px 20px;
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-radius: 10px;
        border: 1px solid #e2e8f0;
    }

    .gantt-filters .filter-group {
        min-width: 140px;
    }

    .gantt-filters .form-select,
    .gantt-filters .form-control {
        font-size: 0.875rem;
        border-color: #e2e8f0;
        border-radius: 6px;
        transition: all 0.2s ease;
    }

    .gantt-filters .form-select:focus,
    .gantt-filters .form-control:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .gantt-filters .input-group-text {
        border-color: #e2e8f0;
        border-radius: 6px 0 0 6px;
    }

    .gantt-filters .btn {
        font-size: 0.875rem;
        padding: 0.375rem 1rem;
        border-radius: 6px;
    }

    .gantt-filters .btn-primary {
        background: #3b82f6;
        border-color: #3b82f6;
    }

    .gantt-filters .btn-primary:hover {
        background: #2563eb;
        border-color: #2563eb;
    }

    .gantt-filters .btn-outline-secondary {
        border-color: #e2e8f0;
        color: #64748b;
    }

    .gantt-filters .btn-outline-secondary:hover {
        background: #f1f5f9;
        border-color: #cbd5e1;
        color: #475569;
    }

    .active-filters {
        padding: 8px 12px;
        background: #eff6ff;
        border-radius: 6px;
        border-left: 3px solid #3b82f6;
    }

    /* Responsive adjustments for filters */
    @media (max-width: 768px) {
        .gantt-filters {
            flex-direction: column;
            align-items: stretch;
        }
        
        .gantt-filters .filter-group {
            width: 100%;
        }
        
        .gantt-filters form {
            flex-direction: column;
            width: 100%;
        }
        
        .gantt-filters .d-flex {
            flex-wrap: wrap;
        }
    }

    /* ============================================
       CRITICAL PATH FLOWCHART MODAL STYLES
       ============================================ */
    
    #criticalPathFlowchartModal .modal-fullscreen {
        max-width: 100%;
    }
    
    .flowchart-legend .legend-box {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 2px solid;
    }
    
    .flowchart-legend .legend-box.critical {
        background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        border-color: #7f1d1d;
        box-shadow: 0 0 8px rgba(220, 38, 38, 0.6);
    }
    
    .flowchart-legend .legend-box.non-critical {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        border-color: #1d4ed8;
    }
    
    .flowchart-legend .legend-box.start-node {
        background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        border-color: #15803d;
    }
    
    .flowchart-legend .legend-box.end-node {
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        border-color: #6d28d9;
    }
    
    /* Flowchart task nodes */
    .fc-task-node {
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .fc-task-node:hover {
        filter: brightness(1.15);
    }
    
    .fc-task-node rect {
        rx: 8;
        ry: 8;
    }
    
    .fc-task-node.critical rect {
        fill: url(#criticalGradient);
        stroke: #7f1d1d;
        stroke-width: 3;
        filter: drop-shadow(0 0 10px rgba(220, 38, 38, 0.6));
    }
    
    .fc-task-node.non-critical rect {
        fill: url(#nonCriticalGradient);
        stroke: #1d4ed8;
        stroke-width: 2;
    }
    
    .fc-task-node.start-node rect {
        stroke: #15803d;
        stroke-width: 3;
        stroke-dasharray: 5, 3;
    }
    
    .fc-task-node.end-node rect {
        stroke: #6d28d9;
        stroke-width: 3;
        stroke-dasharray: 5, 3;
    }
    
    .fc-task-title {
        font-size: 12px;
        font-weight: 600;
        fill: white;
    }
    
    .fc-task-slack {
        font-size: 10px;
        fill: rgba(255, 255, 255, 0.9);
    }
    
    .fc-task-duration {
        font-size: 9px;
        fill: rgba(255, 255, 255, 0.7);
    }
    
    .fc-dependency-arrow {
        stroke: #f59e0b;
        stroke-width: 2;
        fill: none;
    }
    
    .fc-dependency-arrow.critical-arrow {
        stroke: #ef4444;
        stroke-width: 3;
    }
    
    /* Phase separator lines */
    .fc-phase-separator {
        stroke: rgba(255, 255, 255, 0.2);
        stroke-width: 2;
        stroke-dasharray: 10, 5;
    }
    
    .fc-phase-label {
        font-size: 16px;
        font-weight: 700;
        fill: rgba(255, 255, 255, 0.8);
    }

    /* View Network Diagram Button */
    #show-critical-path-flowchart {
        background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
        border: none;
        color: white;
        font-weight: 500;
        padding: 8px 16px;
        transition: all 0.2s ease;
    }
    
    #show-critical-path-flowchart:hover {
        background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-3">
        <div class="col">
            <h1>
                <i class="fas fa-project-diagram me-2"></i>{{ board.name }}
            </h1>
        </div>
        <div class="col-auto">
            <a href="{% if is_demo_mode %}{% url 'demo_board_detail' board.id %}{% else %}{% url 'board_detail' board.id %}{% endif %}" class="btn btn-outline-secondary me-2">
                <i class="fas fa-arrow-left me-1"></i> Back to Board
            </a>
        </div>
    </div>

    <!-- Board Navigation Tabs -->
    <ul class="nav nav-tabs board-tabs">
        <li class="nav-item">
            <a class="nav-link" href="{% if is_demo_mode %}{% url 'demo_board_detail' board.id %}{% else %}{% url 'board_detail' board.id %}{% endif %}">
                <i class="fas fa-columns me-1"></i> Kanban View
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{% url 'board_analytics' board.id %}">
                <i class="fas fa-chart-bar me-1"></i> Analytics
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link active" href="{% url 'gantt_chart' board.id %}">
                <i class="fas fa-chart-gantt me-1"></i> Gantt Chart
            </a>
        </li>
    </ul>

    <div class="gantt-container" style="position: relative;">
        <div class="gantt-header">
            <h2>ðŸ“Š Project Timeline</h2>
            <div class="d-flex align-items-center gap-3">
                <div class="view-buttons">
                    <button class="view-btn" data-mode="Day">Day</button>
                    <button class="view-btn active" data-mode="Week">Week</button>
                    <button class="view-btn" data-mode="Month">Month</button>
                </div>
            </div>
        </div>

        <!-- Search and Filter Bar -->
        <div class="gantt-filters mb-3">
            <form method="GET" action="" class="d-flex flex-wrap align-items-center gap-2" id="gantt-filter-form">
                <!-- Search Input -->
                <div class="filter-group flex-grow-1" style="min-width: 200px; max-width: 300px;">
                    <div class="input-group">
                        <span class="input-group-text bg-white border-end-0">
                            <i class="fas fa-search text-muted"></i>
                        </span>
                        <input type="text" name="search" class="form-control border-start-0" 
                               placeholder="Search tasks..." 
                               value="{{ search_query }}"
                               id="gantt-search-input">
                    </div>
                </div>
                
                <!-- Status Filter -->
                <div class="filter-group">
                    <select name="status" class="form-select" id="gantt-status-filter" onchange="this.form.submit()">
                        <option value="">All Status</option>
                        <option value="active" {% if status_filter == 'active' %}selected{% endif %}>ðŸŸ¢ Active Only</option>
                        <option value="todo" {% if status_filter == 'todo' %}selected{% endif %}>ðŸ“‹ To Do</option>
                        <option value="in_progress" {% if status_filter == 'in_progress' %}selected{% endif %}>ðŸ”„ In Progress</option>
                        <option value="done" {% if status_filter == 'done' %}selected{% endif %}>âœ… Done</option>
                    </select>
                </div>
                
                <!-- Priority Filter -->
                <div class="filter-group">
                    <select name="priority" class="form-select" id="gantt-priority-filter" onchange="this.form.submit()">
                        <option value="">All Priorities</option>
                        {% for value, label in priority_choices %}
                        <option value="{{ value }}" {% if priority_filter == value %}selected{% endif %}>{{ label }}</option>
                        {% endfor %}
                    </select>
                </div>
                
                <!-- Assignee Filter -->
                <div class="filter-group">
                    <select name="assignee" class="form-select" id="gantt-assignee-filter" onchange="this.form.submit()">
                        <option value="">All Assignees</option>
                        <option value="unassigned" {% if assignee_filter == 'unassigned' %}selected{% endif %}>Unassigned</option>
                        {% for user in assignees %}
                        <option value="{{ user.id }}" {% if assignee_filter == user.id|stringformat:"s" %}selected{% endif %}>
                            {{ user.get_full_name|default:user.username }}
                        </option>
                        {% endfor %}
                    </select>
                </div>
                
                <!-- Search Button -->
                <button type="submit" class="btn btn-primary">
                    <i class="fas fa-filter me-1"></i> Apply
                </button>
                
                <!-- Clear Filters -->
                {% if search_query or status_filter or priority_filter or assignee_filter %}
                <a href="{% url 'gantt_chart' board.id %}" class="btn btn-outline-secondary">
                    <i class="fas fa-times me-1"></i> Clear
                </a>
                {% endif %}
            </form>
            
            <!-- Active Filters Summary -->
            {% if search_query or status_filter or priority_filter or assignee_filter %}
            <div class="active-filters mt-2">
                <small class="text-muted">
                    <i class="fas fa-filter me-1"></i>
                    Showing {{ tasks.count }} task{{ tasks.count|pluralize }}
                    {% if search_query %} matching "{{ search_query }}"{% endif %}
                    {% if status_filter %} with status: {{ status_filter }}{% endif %}
                    {% if priority_filter %} with priority: {{ priority_filter }}{% endif %}
                </small>
            </div>
            {% endif %}
        </div>

        {% if has_phases %}
        <!-- Phase Information Panel -->
        <div class="phase-info-panel" id="phase-info-panel">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <strong><i class="fas fa-layer-group me-1"></i> Phases</strong>
                <small class="text-muted">Click a phase to expand/collapse</small>
            </div>
            <div id="phase-items-container">
                <!-- Phase items will be populated by JavaScript -->
            </div>
        </div>
        {% endif %}

        {% if tasks %}
            <!-- Critical Path Toggle, Flowchart Button, and Add Milestone -->
            <div class="d-flex justify-content-end mb-3 gap-2 align-items-center flex-wrap">
                <button class="btn btn-sm" id="add-milestone-btn" title="Add a milestone marker to the Gantt chart"
                        style="background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); border: none; color: white; font-weight: 500;">
                    <i class="fas fa-diamond me-1"></i> Add Milestone
                </button>
                <button class="btn btn-outline-primary btn-sm" id="show-critical-path-flowchart" title="View Critical Path Network Diagram">
                    <i class="fas fa-sitemap me-1"></i> View Network Diagram
                </button>
                <div class="critical-path-toggle">
                    <input type="checkbox" id="critical-path-toggle" checked>
                    <label for="critical-path-toggle">
                        <span class="cp-indicator"></span>
                        Show Critical Path
                    </label>
                </div>
            </div>

            <!-- Gantt Chart Wrapper - this div will be cleared and recreated on each render -->
            <div id="gantt-chart-wrapper">
                <svg id="gantt"></svg>
            </div>
            
            <!-- Custom Tooltip -->
            <div class="gantt-tooltip" id="gantt-tooltip"></div>
            
            <!-- Legend -->
            <div class="gantt-legend">
                <strong>Legend:</strong>
                <div class="legend-item">
                    <span class="legend-color" style="background: #94a3b8;"></span>
                    <span>Low Priority</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #3b82f6;"></span>
                    <span>Medium Priority</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #f59e0b;"></span>
                    <span>High Priority</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #ef4444;"></span>
                    <span>Urgent Priority</span>
                </div>
                <div class="legend-item">
                    <svg width="22" height="16" style="vertical-align: middle;">
                        <circle cx="11" cy="8" r="7" fill="rgba(59,130,246,0.3)" stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
                        <text x="11" y="8" text-anchor="middle" dominant-baseline="middle" font-size="8" font-weight="700" fill="white">AB</text>
                    </svg>
                    <span>Assignee</span>
                </div>
                {% if has_phases %}
                <div class="legend-item">
                    <span class="legend-color" style="background: #6366f1;"></span>
                    <span>Phase</span>
                </div>
                {% endif %}
                <div class="legend-item" id="critical-path-legend">
                    <span class="legend-color" style="background: #dc2626; border: 2px solid #991b1b;"></span>
                    <span>Critical Path</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color" style="background: #7c3aed; border: 2px solid #5b21b6; box-shadow: 0 0 6px rgba(124,58,237,0.7);"></span>
                    <svg width="14" height="14" style="vertical-align:middle; margin-left:-2px; margin-right:2px; flex-shrink:0;">
                        <polygon points="7,1 13,7 7,13 1,7" fill="#7c3aed" stroke="#5b21b6" stroke-width="1.5"/>
                    </svg>
                    <span>Milestone</span>
                </div>
                <div class="legend-item" style="margin-left: auto;">
                    <svg width="40" height="12" style="vertical-align: middle;">
                        <defs>
                            <marker id="arrowhead-legend" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                                <polygon points="0 0, 6 3, 0 6" fill="#64748b"/>
                            </marker>
                        </defs>
                        <path d="M 2 6 L 30 6" stroke="#64748b" stroke-width="2" fill="none" marker-end="url(#arrowhead-legend)"/>
                    </svg>
                    <span>Dependency</span>
                </div>
            </div>
        {% else %}
            {% if any_filters_active %}
            <div class="empty-state">
                <i class="fas fa-search"></i>
                <h3>No Tasks Found</h3>
                <p>No tasks match your current filters{% if search_query %}: <strong>"{{ search_query }}"</strong>{% endif %}. Try adjusting your search or filters.</p>
                <a href="{% url 'gantt_chart' board.id %}" class="btn btn-outline-secondary me-2">
                    <i class="fas fa-times me-1"></i> Clear Filters
                </a>
                <a href="{% if is_demo_mode %}{% url 'demo_board_detail' board.id %}{% else %}{% url 'board_detail' board.id %}{% endif %}" class="btn btn-primary">
                    <i class="fas fa-arrow-left me-1"></i> Go to Board
                </a>
            </div>
            {% else %}
            <div class="empty-state">
                <i class="fas fa-calendar-times"></i>
                <h3>No Tasks with Dates</h3>
                <p>Add start dates and due dates to your tasks to see them on the Gantt chart.</p>
                <a href="{% if is_demo_mode %}{% url 'demo_board_detail' board.id %}{% else %}{% url 'board_detail' board.id %}{% endif %}" class="btn btn-primary">
                    <i class="fas fa-arrow-left me-1"></i> Go to Board
                </a>
            </div>
            {% endif %}
        {% endif %}
    </div>
</div>

<!-- Add Milestone Modal -->
<div class="modal fade" id="addMilestoneModal" tabindex="-1" aria-labelledby="addMilestoneModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content" style="border: 2px solid #7c3aed; border-radius: 12px; overflow: hidden;">
            <div class="modal-header" style="background: linear-gradient(135deg, #6d28d9 0%, #4c1d95 100%); color: white;">
                <h5 class="modal-title" id="addMilestoneModalLabel">
                    <svg width="18" height="18" style="vertical-align:middle; margin-right:8px; flex-shrink:0;">
                        <polygon points="9,1 17,9 9,17 1,9" fill="#c4b5fd" stroke="#7c3aed" stroke-width="1.5"/>
                    </svg>
                    Add Milestone
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="milestone-form-alert" class="alert d-none" role="alert"></div>
                <div class="mb-3">
                    <label for="milestone-name" class="form-label fw-semibold">Name <span class="text-danger">*</span></label>
                    <input type="text" class="form-control" id="milestone-name" placeholder="e.g., MVP Release, Phase 1 Complete" maxlength="200">
                </div>
                <div class="mb-3">
                    <label for="milestone-description" class="form-label fw-semibold">Description</label>
                    <textarea class="form-control" id="milestone-description" rows="2" placeholder="What does this milestone represent?"></textarea>
                </div>
                {% if has_phases %}
                <div class="mb-3">
                    <label for="milestone-phase" class="form-label fw-semibold">Phase</label>
                    <select class="form-select" id="milestone-phase">
                        <option value="">â€” No specific phase â€”</option>
                        {% for i in num_phases|make_range %}
                        <option value="Phase {{ forloop.counter }}">Phase {{ forloop.counter }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% else %}
                <input type="hidden" id="milestone-phase" value="">
                {% endif %}
                <div class="mb-3">
                    <label for="milestone-position-after" class="form-label fw-semibold">Follows task <small class="text-muted fw-normal">(row position in Gantt)</small></label>
                    <select class="form-select" id="milestone-position-after">
                        <option value="">â€” At end of phase â€”</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="milestone-due-date" class="form-label fw-semibold">Due Date <span class="text-danger">*</span></label>
                    <input type="date" class="form-control" id="milestone-due-date">
                </div>
                <div class="mb-3">
                    <label for="milestone-status" class="form-label fw-semibold">Status</label>
                    <select class="form-select" id="milestone-status">
                        <option value="upcoming">Upcoming</option>
                        <option value="completed">Completed</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn" id="save-milestone-btn"
                        style="background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); border: none; color: white; font-weight: 600;">
                    <svg width="14" height="14" style="vertical-align:middle; margin-right:4px; flex-shrink:0;">
                        <polygon points="7,1 13,7 7,13 1,7" fill="white" stroke="rgba(255,255,255,0.6)" stroke-width="1"/>
                    </svg>
                    Save Milestone
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Critical Path Network Diagram Modal -->
<div class="modal fade" id="criticalPathFlowchartModal" tabindex="-1" aria-labelledby="criticalPathFlowchartModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header bg-dark text-white">
                <h5 class="modal-title" id="criticalPathFlowchartModalLabel">
                    <i class="fas fa-sitemap me-2"></i>Critical Path Network Diagram
                </h5>
                <div class="d-flex align-items-center gap-3 ms-auto">
                    <div class="form-check form-switch text-white">
                        <input class="form-check-input" type="checkbox" id="flowchart-phase-filter" checked>
                        <label class="form-check-label small" for="flowchart-phase-filter">Show All Phases</label>
                    </div>
                    <select class="form-select form-select-sm bg-dark text-white border-secondary" id="flowchart-phase-select" style="width: auto;">
                        <option value="all">All Phases</option>
                    </select>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
            </div>
            <div class="modal-body p-0" style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); overflow: auto;">
                <!-- Legend -->
                <div class="flowchart-legend p-3 bg-dark bg-opacity-50">
                    <div class="d-flex gap-4 flex-wrap justify-content-center">
                        <div class="legend-item-fc d-flex align-items-center gap-2">
                            <div class="legend-box critical"></div>
                            <span class="text-white small">Critical Path (0 slack)</span>
                        </div>
                        <div class="legend-item-fc d-flex align-items-center gap-2">
                            <div class="legend-box non-critical"></div>
                            <span class="text-white small">Non-Critical (has slack)</span>
                        </div>
                        <div class="legend-item-fc d-flex align-items-center gap-2">
                            <svg width="40" height="20">
                                <defs>
                                    <marker id="arrow-legend-fc" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
                                        <polygon points="0 0, 8 4, 0 8" fill="#f59e0b"/>
                                    </marker>
                                </defs>
                                <path d="M 2 10 L 30 10" stroke="#f59e0b" stroke-width="2" fill="none" marker-end="url(#arrow-legend-fc)"/>
                            </svg>
                            <span class="text-white small">Dependency</span>
                        </div>
                    </div>
                </div>
                <!-- Flowchart Container -->
                <div id="flowchart-container" style="min-height: 600px; padding: 20px;">
                    <svg id="flowchart-svg" width="100%" height="100%"></svg>
                </div>
            </div>
            <div class="modal-footer bg-dark border-top border-secondary">
                <div class="text-muted small me-auto">
                    <i class="fas fa-info-circle me-1"></i>
                    <span id="flowchart-stats">Loading...</span>
                </div>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
<script>
    // Suppress known Frappe Gantt library errors related to $bar
    // These occur during mouse interactions when bars are not yet rendered
    window.addEventListener('error', function(event) {
        if (event.message && (
            event.message.includes("Cannot read properties of undefined (reading '$bar')") ||
            event.message.includes("Cannot read properties of undefined (reading 'group')")
        )) {
            event.preventDefault();
            event.stopPropagation();
            return true; // Suppress the error
        }
    }, true);
    
    {% if tasks %}
    // Collect all task IDs for validation
    const allTaskIds = new Set([{% for task in tasks %}'{{ task.id }}'{% if not forloop.last %},{% endif %}{% endfor %}{% if milestones %}{% for m in milestones %},'milestone-{{ m.id }}'{% endfor %}{% endif %}]);
    
    console.log('===== GANTT CHART DEBUG =====');
    console.log('Board: {{ board.name }}');
    console.log('Total tasks:', {{ tasks.count }});
    console.log('All task IDs:', Array.from(allTaskIds));
    
    // Phase data from Django (for phase-based view)
    const phasesData = {{ phases_data_json|safe }};
    const hasPhases = {{ has_phases|yesno:"true,false" }};
    const numPhases = {{ num_phases|default:0 }};

    // View state
    // When search/filter is active, force 'all' view so individual matched task
    // bars are directly visible instead of being hidden inside collapsed phase bars.
    const anyFiltersActive = {{ any_filters_active|yesno:"true,false" }};
    let currentView = (hasPhases && !anyFiltersActive) ? 'phases' : 'all';
    let expandedPhases = new Set();

    // Prepare task data for Gantt chart with validated dependencies
    const tasks = [
        {% for task in tasks %}
        {
            id: '{{ task.id }}',
            name: '{{ task.title|escapejs }}',
            fullName: '{{ task.title|escapejs }}',
            start: '{{ task.start_date|date:"Y-m-d" }}',
            end: '{{ task.due_date|date:"Y-m-d" }}',
            progress: {{ task.progress|default:0 }},
            dependencies: '{% for dep in task.dependencies.all %}{{ dep.id }}{% if not forloop.last %},{% endif %}{% endfor %}',
            custom_class: 'status-{{ task.column.name|lower|cut:" "}}',
            status: '{% if "done" in task.column.name|lower %}done{% elif "progress" in task.column.name|lower %}in_progress{% else %}todo{% endif %}',
            priority: '{{ task.priority }}',
            assigned_to: '{% if task.assigned_to %}{{ task.assigned_to.username }}{% else %}Unassigned{% endif %}',
            assignee_first_name: '{% if task.assigned_to %}{{ task.assigned_to.first_name|escapejs }}{% endif %}',
            assignee_last_name: '{% if task.assigned_to %}{{ task.assigned_to.last_name|escapejs }}{% endif %}',
            phase: '{{ task.phase|default:""|escapejs }}'
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];
    
    console.log('Raw tasks data:', tasks);
    
    // Validate and fix task dates to prevent negative width errors
    // frappe-gantt requires end date >= start date
    tasks.forEach(task => {
        const startDate = new Date(task.start);
        const endDate = new Date(task.end);
        
        // Check for invalid dates
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            console.warn(`Task ${task.id} has invalid dates, using today as fallback`);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            task.start = today.toISOString().split('T')[0];
            task.end = tomorrow.toISOString().split('T')[0];
        } else if (endDate < startDate) {
            // If end date is before start date, swap them
            console.warn(`Task ${task.id} has end date before start date, swapping`);
            const temp = task.start;
            task.start = task.end;
            task.end = temp;
        } else if (endDate.getTime() === startDate.getTime()) {
            // If dates are the same, add 1 day to end date to ensure visible bar width
            console.warn(`Task ${task.id} has same start and end date, extending by 1 day`);
            const newEnd = new Date(endDate);
            newEnd.setDate(newEnd.getDate() + 1);
            task.end = newEnd.toISOString().split('T')[0];
        }
    });
    
    // Validate and clean up dependencies
    tasks.forEach(task => {
        if (task.dependencies) {
            // Handle both string and array dependencies
            let depList;
            if (typeof task.dependencies === 'string') {
                depList = task.dependencies.split(',');
            } else if (Array.isArray(task.dependencies)) {
                depList = task.dependencies;
            } else {
                depList = [];
            }
            const depIds = depList.filter(id => {
                const trimmedId = String(id).trim();
                // Only include dependencies that exist in our task list
                // and are not self-referencing
                return trimmedId && allTaskIds.has(trimmedId) && trimmedId !== task.id;
            });
            task.dependencies = depIds.join(',');
            
            // Debug logging
            if (depIds.length > 0) {
                console.log(`Task ${task.id} (${task.name}) depends on: ${task.dependencies}`);
            }
        }
    });

    // ============================================
    // MILESTONES DATA
    // ============================================
    // Milestones are stored as Tasks with item_type='milestone'
    // They appear as distinct glowing diamond-marked bars on the Gantt chart
    const ganttMilestones = [
        {% for milestone in milestones %}
        {% if milestone.due_date %}
        {
            id: 'milestone-{{ milestone.id }}',
            name: 'â—† {{ milestone.title|escapejs }}',
            fullName: '{{ milestone.title|escapejs }}',
            start: '{% if milestone.start_date %}{{ milestone.start_date|date:"Y-m-d" }}{% else %}{{ milestone.due_date|date:"Y-m-d" }}{% endif %}',
            end: '{{ milestone.due_date|date:"Y-m-d" }}',
            progress: 0,
            dependencies: '',
            custom_class: 'milestone-bar',
            status: '{{ milestone.milestone_status|default:"upcoming" }}',
            priority: 'medium',
            assigned_to: 'Unassigned',
            assignee_first_name: '',
            assignee_last_name: '',
            phase: '{{ milestone.phase|default:""|escapejs }}',
            positionAfterId: '{{ milestone.position_after_task_id|default:"" }}',
            isMilestone: true,
            milestoneStatus: '{{ milestone.milestone_status|default:"upcoming" }}',
            milestoneDbId: '{{ milestone.id }}'
        }{% if not forloop.last %},{% endif %}
        {% endif %}
        {% endfor %}
    ];
    // Helper: add N days to a YYYY-MM-DD string using UTC (avoids timezone shift bugs)
    function addDaysUTC(dateStr, n) {
        const parts = dateStr.split('-').map(Number);
        const d = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2] + n));
        return d.toISOString().split('T')[0];
    }

    // Fix milestone dates (start == end â†’ extend end by 1 day for visible bar width)
    // IMPORTANT: use UTC arithmetic only â€” setDate()+toISOString() shifts the date in
    // positive-offset timezones (e.g. IST +5:30 turns Mar 21 â†’ Mar 22).
    ganttMilestones.forEach(m => {
        const startDate = new Date(m.start);
        const endDate = new Date(m.end);
        // Always store the true due date before we extend m.end for bar width
        m.dueDate = m.start;
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            const todayStr = new Date().toISOString().split('T')[0];
            m.start = todayStr;
            m.dueDate = todayStr;
            m.end = addDaysUTC(todayStr, 1);
        } else if (endDate <= startDate) {
            // Extend end by exactly 1 day in UTC so the bar has visible width
            m.end = addDaysUTC(m.start, 1);
        }
    });
    console.log('Gantt milestones:', ganttMilestones);

    // When a search or filter is active, hide milestones so only matching tasks
    // are shown â€” milestones are not searchable items and would confuse results.
    const visibleMilestones = anyFiltersActive ? [] : ganttMilestones;

    /**
     * Build the Gantt task list inserting each milestone immediately after its
     * position_after_task (if set), otherwise at the end of the list.
     * This controls the vertical row order in the Gantt chart.
     */
    function buildOrderedTaskList(regularTasks, milestones) {
        const result = [...regularTasks];
        milestones.forEach(m => {
            if (m.positionAfterId) {
                const idx = result.findIndex(t => String(t.id) === String(m.positionAfterId));
                if (idx !== -1) {
                    result.splice(idx + 1, 0, m);
                    return;
                }
            }
            result.push(m); // fallback: append at end
        });
        return result;
    }

    // ============================================
    // CRITICAL PATH METHOD (CPM) IMPLEMENTATION
    // ============================================
    
    let showCriticalPath = true; // Default: ON
    let criticalPathTasks = new Set(); // Store task IDs on critical path
    
    /**
     * Calculate Critical Path for the entire project
     * Handles two scenarios:
     * 1. With Phases: Calculate critical path separately for each phase
     * 2. Without Phases: Calculate critical path across all tasks
     */
    function calculateProjectCriticalPath() {
        const allCriticalTasks = new Set();
        
        if (hasPhases) {
            // WITH PHASES: Calculate critical path for each phase independently
            console.log('%c CPM: Calculating critical path per phase', 'background: #6366f1; color: white; padding: 2px 6px;');
            
            for (let i = 1; i <= numPhases; i++) {
                const phaseName = `Phase ${i}`;
                const phaseTasks = tasks.filter(t => t.phase === phaseName);
                
                if (phaseTasks.length > 0) {
                    const phaseCriticalPath = calculateCriticalPath(phaseTasks);
                    console.log(`  Phase ${i}: ${phaseCriticalPath.size} critical tasks out of ${phaseTasks.length}`);
                    
                    // Merge into all critical tasks
                    phaseCriticalPath.forEach(taskId => allCriticalTasks.add(taskId));
                }
            }
        } else {
            // WITHOUT PHASES: Calculate critical path across all tasks
            console.log('%c CPM: Calculating project-wide critical path', 'background: #6366f1; color: white; padding: 2px 6px;');
            
            const projectCriticalPath = calculateCriticalPath(tasks);
            projectCriticalPath.forEach(taskId => allCriticalTasks.add(taskId));
        }
        
        console.log(`%c Total critical path tasks: ${allCriticalTasks.size}`, 'background: #dc2626; color: white; padding: 2px 6px;');
        return allCriticalTasks;
    }
    
    /**
     * Calculate the Critical Path using the Critical Path Method (CPM) algorithm
     * 
     * Forward pass: Calculate earliest start (ES) and earliest finish (EF) for each task
     * Backward pass: Calculate latest start (LS) and latest finish (LF) for each task
     * Slack = LS - ES (or LF - EF)
     * Tasks with zero slack are on the critical path
     */
    function calculateCriticalPath(taskList) {
        if (!taskList || taskList.length === 0) return new Set();
        
        // Filter to only include tasks with valid dates (exclude phases)
        const validTasks = taskList.filter(t => 
            t.start && t.end && 
            t.start !== '' && t.end !== '' && 
            !t.isPhase
        );
        
        if (validTasks.length === 0) return new Set();
        
        // Create a set of valid task IDs for quick lookup
        const validTaskIds = new Set(validTasks.map(t => String(t.id)));
        
        // Build task map for quick lookup - FIRST PASS: create all entries
        const taskMap = new Map();
        validTasks.forEach(task => {
            // Convert task.dependencies to a string no matter what type it is.
            // Using || '' is unsafe because [] is truthy, causing [].split() TypeError.
            let rawDeps = task.dependencies;
            if (Array.isArray(rawDeps)) {
                rawDeps = rawDeps.join(',');
            } else if (typeof rawDeps !== 'string') {
                rawDeps = String(rawDeps || '');
            }
            taskMap.set(String(task.id), {
                id: String(task.id),
                name: task.name,
                start: new Date(task.start),
                end: new Date(task.end),
                duration: Math.max(1, Math.ceil((new Date(task.end) - new Date(task.start)) / (1000 * 60 * 60 * 24))),
                rawDependencies: rawDeps,
                dependencies: [], // Will be populated in second pass
                successors: [],
                ES: null, // Earliest Start
                EF: null, // Earliest Finish
                LS: null, // Latest Start
                LF: null, // Latest Finish
                slack: null
            });
        });
        
        // SECOND PASS: Parse dependencies now that all tasks are in the map
        taskMap.forEach((task, taskId) => {
            if (task.rawDependencies) {
                // Guard: rawDependencies must be a string before calling .split
                const rawStr = typeof task.rawDependencies === 'string'
                    ? task.rawDependencies
                    : (Array.isArray(task.rawDependencies) ? task.rawDependencies.join(',') : String(task.rawDependencies));
                const depIds = rawStr.split(',')
                    .map(d => String(d).trim())
                    .filter(d => d && validTaskIds.has(d));
                task.dependencies = depIds;
            }
        });
        
        // Build successor relationships
        taskMap.forEach((task, taskId) => {
            task.dependencies.forEach(depId => {
                const depTask = taskMap.get(depId);
                if (depTask) {
                    depTask.successors.push(taskId);
                }
            });
        });
        
        // FORWARD PASS: Calculate ES and EF
        // ES = max(EF of all predecessors) or 0 if no predecessors
        // EF = ES + duration
        // NOTE: We use task durations and dependencies only, not actual calendar dates
        
        // Find the earliest start among all tasks (for reference)
        let projectStart = null;
        taskMap.forEach(task => {
            if (!projectStart || task.start < projectStart) {
                projectStart = task.start;
            }
        });
        
        // Topological sort for forward pass
        const visited = new Set();
        const sorted = [];
        
        function topologicalSort(taskId) {
            if (visited.has(taskId)) return;
            visited.add(taskId);
            
            const task = taskMap.get(taskId);
            if (!task) return;
            
            // Visit all dependencies first
            task.dependencies.forEach(depId => {
                if (taskMap.has(depId)) {
                    topologicalSort(depId);
                }
            });
            
            sorted.push(taskId);
        }
        
        // Sort all tasks
        taskMap.forEach((_, taskId) => topologicalSort(taskId));
        
        // Forward pass - calculate ES and EF based purely on dependencies
        sorted.forEach(taskId => {
            const task = taskMap.get(taskId);
            if (!task) return;
            
            // ES = max(EF of predecessors) or project start if no predecessors
            if (task.dependencies.length === 0) {
                // No predecessors - start at project start
                task.ES = new Date(projectStart);
            } else {
                // ES = max(EF of all predecessors)
                let maxPredEF = new Date(projectStart);
                task.dependencies.forEach(depId => {
                    const dep = taskMap.get(depId);
                    if (dep && dep.EF && dep.EF > maxPredEF) {
                        maxPredEF = new Date(dep.EF);
                    }
                });
                task.ES = maxPredEF;
            }
            
            // EF = ES + duration
            task.EF = new Date(task.ES);
            task.EF.setDate(task.EF.getDate() + task.duration);
        });
        
        // Find project end date (latest EF)
        let projectEnd = null;
        taskMap.forEach(task => {
            if (!projectEnd || (task.EF && task.EF > projectEnd)) {
                projectEnd = task.EF;
            }
        });
        
        // BACKWARD PASS: Calculate LF and LS
        // LF = min(LS of all successors) or project end if no successors
        // LS = LF - duration
        
        // Reverse order for backward pass
        const reverseSorted = [...sorted].reverse();
        
        reverseSorted.forEach(taskId => {
            const task = taskMap.get(taskId);
            if (!task) return;
            
            // LF = min(LS of successors) or project end
            if (task.successors.length === 0) {
                task.LF = projectEnd;
            } else {
                let minSuccLS = projectEnd;
                task.successors.forEach(succId => {
                    const succ = taskMap.get(succId);
                    if (succ && succ.LS && succ.LS < minSuccLS) {
                        minSuccLS = succ.LS;
                    }
                });
                task.LF = minSuccLS;
            }
            
            // LS = LF - duration
            task.LS = new Date(task.LF);
            task.LS.setDate(task.LS.getDate() - task.duration);
        });
        
        // Calculate slack and identify critical path
        const criticalPath = new Set();
        
        console.log('%c Slack Analysis for all tasks:', 'background: #059669; color: white; padding: 2px 6px;');
        taskMap.forEach((task, taskId) => {
            if (task.ES && task.LS) {
                // Slack = LS - ES (in days)
                task.slack = Math.round((task.LS - task.ES) / (1000 * 60 * 60 * 24));
                
                // Log detailed info for each task
                console.log(`  Task ${taskId} "${task.name.substring(0, 20)}...": ES=${task.ES.toDateString()}, LS=${task.LS.toDateString()}, Slack=${task.slack} days ${task.slack <= 1 ? 'ðŸ”´ CRITICAL' : 'âšª Non-critical'}`);
                
                // Tasks with zero or near-zero slack are on the critical path
                // Use <= 1 to account for rounding errors
                if (task.slack <= 1) {
                    criticalPath.add(taskId);
                }
            } else {
                console.log(`  Task ${taskId} "${task.name.substring(0, 20)}...": ES or LS not calculated!`);
            }
        });
        
        console.log('%c Critical Path Analysis Complete', 'background: #dc2626; color: white; padding: 4px 8px; border-radius: 4px;');
        console.log(`Found ${criticalPath.size} tasks on critical path out of ${taskMap.size} total tasks`);
        
        // Log critical path tasks
        const criticalTasks = Array.from(criticalPath).map(id => {
            const t = taskMap.get(id);
            return t ? `${t.name.substring(0, 25)}...` : id;
        });
        console.log('Critical path tasks:', criticalTasks);
        
        return criticalPath;
    }
    
    /**
     * Apply critical path styling to task bars
     */
    function applyCriticalPathStyling() {
        console.log('%c Applying Critical Path Styling', 'background: #7c3aed; color: white; padding: 2px 6px;');
        console.log('showCriticalPath:', showCriticalPath);
        console.log('criticalPathTasks:', Array.from(criticalPathTasks));
        
        if (!showCriticalPath) {
            // Remove critical path styling from all bars and wrappers
            document.querySelectorAll('.bar-wrapper .bar[data-critical-path="true"]').forEach(bar => {
                bar.removeAttribute('data-critical-path');
            });
            document.querySelectorAll('.bar-wrapper[data-critical-path="true"]').forEach(wrapper => {
                wrapper.removeAttribute('data-critical-path');
            });
            console.log('Critical path styling removed');
            return;
        }
        
        let appliedCount = 0;
        // Apply critical path attribute to tasks on the critical path
        criticalPathTasks.forEach(taskId => {
            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${taskId}"]`);
            if (barWrapper) {
                barWrapper.setAttribute('data-critical-path', 'true');
                const bar = barWrapper.querySelector('.bar');
                if (bar) {
                    bar.setAttribute('data-critical-path', 'true');
                    appliedCount++;
                    console.log(`  âœ… Applied to task ${taskId}`);
                }
            } else {
                console.log(`  âŒ Bar wrapper not found for task ${taskId}`);
            }
        });
        console.log(`Applied critical path styling to ${appliedCount} tasks`);
    }
    
    /**
     * Toggle critical path visibility
     */
    function toggleCriticalPath(enabled) {
        showCriticalPath = enabled;
        applyCriticalPathStyling();
        
        // Update legend visibility
        const legend = document.getElementById('critical-path-legend');
        if (legend) {
            legend.style.opacity = enabled ? '1' : '0.5';
        }
    }
    
    // Initialize critical path toggle event listener
    document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.getElementById('critical-path-toggle');
        if (toggle) {
            toggle.addEventListener('change', function() {
                toggleCriticalPath(this.checked);
            });
        }
    });

    let ganttChart = null;
    let currentViewMode = 'Week';

    // Initialize Gantt chart
    function initGantt(viewMode = 'Week') {
        const chartWrapper = document.getElementById('gantt-chart-wrapper');
        currentViewMode = viewMode;
        
        // Set body attribute for view-specific CSS styling
        document.body.setAttribute('data-view-mode', viewMode);
        
        // Adjust bar height based on view mode for better visibility
        const barHeight = viewMode === 'Month' ? 40 : 32;
        const barPadding = viewMode === 'Month' ? 24 : 20;
        
        if (ganttChart) {
            // If chart exists and we're just changing view mode, use the built-in method
            try {
                // Add transitioning class to maintain visibility during view change
                chartWrapper.classList.add('transitioning');
                
                // Apply styling BEFORE view mode change to prevent color flash
                applyCustomStyling();
                
                ganttChart.change_view_mode(viewMode);
                
                // After changing view mode, reapply custom attributes and enhancements
                // Use requestAnimationFrame for smoother rendering
                requestAnimationFrame(() => {
                    applyCustomStyling();
                    // Second pass to ensure all elements are styled
                    requestAnimationFrame(() => {
                        applyCustomStyling();
                        enhanceDependencyArrows();
                        // Remove transitioning class after styling is complete
                        chartWrapper.classList.remove('transitioning');
                    });
                });
                return;
            } catch (e) {
                console.warn('Error changing view mode, reinitializing chart:', e);
                // If there's an error, fall through to recreate the chart
                ganttChart = null;
            }
        }
        
        // Hide chart during reconstruction to prevent visual glitch
        chartWrapper.classList.remove('chart-ready');
        
        // Completely clear the wrapper and recreate fresh SVG
        chartWrapper.innerHTML = '<svg id="gantt"></svg>';
        
        // Force a reflow to ensure DOM is updated
        void chartWrapper.offsetHeight;
        
        // Debug: Log tasks with dependencies
        console.log('Tasks with dependencies:', tasks.filter(t => t.dependencies).map(t => ({
            id: t.id,
            name: t.name,
            dependencies: t.dependencies
        })));
        
        ganttChart = new Gantt('#gantt', buildOrderedTaskList(tasks, visibleMilestones), {
                view_mode: viewMode,
                bar_height: barHeight,
                bar_corner_radius: 6,
                arrow_curve: 10, // Smooth curves for clean routing
                padding: barPadding,
                date_format: 'YYYY-MM-DD',
                language: 'en',
                custom_popup_html: null, // Disable default popup
                popup_trigger: 'none', // Disable popup entirely for cleaner navigation
                on_click: function(task) {
                    // Redirect to task detail page with current page as return URL
                    const currentUrl = encodeURIComponent(window.location.href);
                    return false; // Prevent default behavior
                },
                on_date_change: function(task, start, end) {
                    // Update task dates via API
                    updateTaskDates(task.id, start, end);
                    return false; // Prevent promise error
                },
                on_progress_change: function(task, progress) {
                    // Update task progress via API
                    updateTaskProgress(task.id, progress);
                    return false; // Prevent promise error
                }
            });

        // Apply custom styling for the first time - use requestAnimationFrame for smoother rendering
        requestAnimationFrame(() => {
            applyCustomStyling();
            
            // Show chart with smooth transition after initial styling
            requestAnimationFrame(() => {
                applyCustomStyling();
                const chartWrapper = document.getElementById('gantt-chart-wrapper');
                if (chartWrapper) {
                    chartWrapper.classList.add('chart-ready');
                }
                
                // Set up arrow polygon observer for this chart instance
                setupArrowPolygonObserver();
                
                // Apply arrow styling after chart is visible
                requestAnimationFrame(() => {
                    enhanceDependencyArrows();
                    
                    // Final cleanup pass for any remaining arrow issues
                    setTimeout(() => {
                        enhanceDependencyArrows();
                    }, 200);
                });
            });
        });
    }

    // Apply all custom styling, attributes, and enhancements
    function applyCustomStyling() {
        // Add custom attributes for regular task bars
        tasks.forEach(task => {
            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${task.id}"]`);
            if (!barWrapper) return;
            
            const barElement = barWrapper.querySelector('.bar');
            if (barElement) {
                // Set priority attribute for color styling
                barElement.setAttribute('data-priority', task.priority);
            }
        });

        // Apply milestone-specific styling
        ganttMilestones.forEach(milestone => {
            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${milestone.id}"]`);
            if (!barWrapper) return;

            const barElement = barWrapper.querySelector('.bar');
            if (barElement) {
                barElement.setAttribute('data-is-milestone', 'true');
                barElement.setAttribute('data-milestone-status', milestone.milestoneStatus || 'upcoming');
                barElement.setAttribute('data-priority', 'medium'); // prevent priority color override clashing

                // Overlay a diamond shape on the milestone bar (if not already done)
                const existingDiamond = barWrapper.querySelector('.milestone-diamond-shape');
                if (!existingDiamond) {
                    try {
                        const barRect = barElement.getBBox();
                        if (barRect.width > 0 && barRect.height > 0) {
                            const cx = barRect.x + barRect.width / 2;
                            const cy = barRect.y + barRect.height / 2;
                            const halfSide = Math.min(barRect.height * 0.46, barRect.width * 0.38, 10);
                            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            diamond.setAttribute('points',
                                `${cx},${cy - halfSide} ${cx + halfSide},${cy} ${cx},${cy + halfSide} ${cx - halfSide},${cy}`
                            );
                            diamond.setAttribute('fill', milestone.milestoneStatus === 'completed' ? 'rgba(16,185,129,0.9)' : 'rgba(255,215,0,0.92)');
                            diamond.setAttribute('stroke', milestone.milestoneStatus === 'completed' ? '#064e3b' : '#92400e');
                            diamond.setAttribute('stroke-width', '1.5');
                            diamond.classList.add('milestone-diamond-shape');
                            barWrapper.appendChild(diamond);
                        }
                    } catch (e) {
                        // getBBox can fail â€“ silently ignore
                    }
                }
            }
        });
        
        // Calculate and apply critical path (only on first call or when tasks change)
        if (criticalPathTasks.size === 0) {
            criticalPathTasks = calculateProjectCriticalPath();
        }
        applyCriticalPathStyling();

        // Enhance dependency arrows with better styling
        enhanceDependencyArrows();

        // Add manual click handlers to all bars for better compatibility
        document.querySelectorAll('.bar-wrapper').forEach(barWrapper => {
            barWrapper.style.cursor = 'pointer';
            // Remove old listeners by cloning the node
            const newBarWrapper = barWrapper.cloneNode(true);
            barWrapper.parentNode.replaceChild(newBarWrapper, barWrapper);
            
            newBarWrapper.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling
                const taskId = this.getAttribute('data-id');
                if (taskId) {
                    // Check if this is a phase bar (id starts with 'phase-')
                    if (taskId.startsWith('phase-')) {
                        // Extract phase name by converting ID back to proper case
                        // 'phase-1' -> 'Phase 1', 'phase-2' -> 'Phase 2', etc.
                        const phaseIdPart = taskId.replace('phase-', '');
                        const phaseName = 'Phase ' + phaseIdPart.split('-').map(word => 
                            word.charAt(0).toUpperCase() + word.slice(1)
                        ).join(' ');
                        togglePhase(phaseName, e);
                    } else if (taskId.startsWith('milestone-')) {
                        // Navigate to the milestone detail page
                        const milestoneDbId = taskId.replace('milestone-', '');
                        const currentUrl = encodeURIComponent(window.location.href);
                        window.location.href = `/milestones/${milestoneDbId}/?next=${currentUrl}`;
                    } else {
                        // Navigate to regular task detail with return URL
                        const currentUrl = encodeURIComponent(window.location.href);
                        window.location.href = `/tasks/${taskId}/?next=${currentUrl}`;
                    }
                }
            });
        });

        // Enhance bars with additional info
        enhanceBarsWithInfo();

        // Add assignee initials to task bars
        addAssigneeInitials();

        // Add tooltip functionality
        addTooltipHandlers();
    }

    // Fix frappe-gantt's arrow rendering - remove distorted polygons and use clean arrowheads
    function enhanceDependencyArrows() {
        const ganttSvg = document.querySelector('#gantt');
        if (!ganttSvg) return;

        // Find or create defs
        let defs = ganttSvg.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            ganttSvg.insertBefore(defs, ganttSvg.firstChild);
        }

        // Check if our custom arrowhead already exists
        let existingMarker = defs.querySelector('#arrowhead-custom');
        if (!existingMarker) {
            // Create ONE clean arrowhead marker with unique ID
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead-custom');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '5');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');

            // Clean filled triangle arrowhead (pointing right)
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0,0 10,5 0,10');
            polygon.setAttribute('fill', '#64748b');
            polygon.classList.add('custom-arrowhead');

            marker.appendChild(polygon);
            defs.appendChild(marker);
        }

        // AGGRESSIVELY remove or hide ALL standalone polygons that are frappe-gantt's default arrow heads
        // These appear as distorted Y-shapes or horizontal Y patterns
        ganttSvg.querySelectorAll('polygon').forEach(polygon => {
            // Keep polygons that are:
            // 1. Inside defs (our custom markers)
            // 2. Our custom arrowhead class
            const isInDefs = polygon.closest('defs');
            const isCustomArrow = polygon.classList.contains('custom-arrowhead');
            
            if (!isInDefs && !isCustomArrow) {
                // First try to remove it
                try {
                    polygon.remove();
                } catch (e) {
                    // If removal fails, hide it with inline styles
                    polygon.style.display = 'none';
                    polygon.style.visibility = 'hidden';
                    polygon.style.opacity = '0';
                    polygon.setAttribute('points', '0,0 0,0 0,0'); // Collapse to nothing
                }
            }
        });

        // Style all arrow paths with proper attributes
        ganttSvg.querySelectorAll('path').forEach(path => {
            const className = path.getAttribute('class') || '';

            // Only target arrow paths (frappe-gantt uses 'arrow' class)
            if (className.includes('arrow')) {
                // Apply clean styling
                path.setAttribute('stroke', '#64748b');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', 'url(#arrowhead-custom)');
                path.style.opacity = '0.8';
                
                // Remove any inline polygon children that might interfere
                path.querySelectorAll('polygon').forEach(p => {
                    if (!p.classList.contains('custom-arrowhead')) {
                        p.remove();
                    }
                });
            }
        });

        // Also look for paths inside .arrow groups and apply same styling
        ganttSvg.querySelectorAll('.arrow path, g.arrow path').forEach(path => {
            path.setAttribute('stroke', '#64748b');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrowhead-custom)');
            path.style.opacity = '0.8';
        });
        
        // Handle arrow groups (g.arrow) - remove any child polygons aggressively
        ganttSvg.querySelectorAll('g.arrow, g[class*="arrow"]').forEach(group => {
            group.querySelectorAll('polygon').forEach(p => {
                if (!p.classList.contains('custom-arrowhead')) {
                    try {
                        p.remove();
                    } catch (e) {
                        p.style.display = 'none';
                        p.setAttribute('points', '0,0 0,0 0,0');
                    }
                }
            });
        });
    }

    // Add tooltip functionality for task bars
    function addTooltipHandlers() {
        const tooltip = document.getElementById('gantt-tooltip');
        if (!tooltip) return;

        // Combine regular tasks and milestones for tooltip registration
        const allGanttItems = [...tasks, ...ganttMilestones];

        allGanttItems.forEach(task => {
            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${task.id}"]`);
            if (!barWrapper) return;

            // Store full task name as data attribute
            barWrapper.setAttribute('data-full-name', task.fullName);
            barWrapper.setAttribute('data-priority', task.priority);
            barWrapper.setAttribute('data-assigned-to', task.assigned_to);
            barWrapper.setAttribute('data-progress', task.progress);
            barWrapper.setAttribute('data-start', task.start);
            barWrapper.setAttribute('data-end', task.end);
            if (task.isMilestone) {
                barWrapper.setAttribute('data-is-milestone', 'true');
                barWrapper.setAttribute('data-milestone-status', task.milestoneStatus || 'upcoming');
                barWrapper.setAttribute('data-due-date', task.dueDate || task.start);
            }

            // Add mouseenter event
            barWrapper.addEventListener('mouseenter', function(e) {
                const fullName = this.getAttribute('data-full-name');
                const priority = this.getAttribute('data-priority');
                const assignedTo = this.getAttribute('data-assigned-to');
                const progress = this.getAttribute('data-progress');
                const startDate = this.getAttribute('data-start');
                const endDate = this.getAttribute('data-end');
                const isMilestone = this.getAttribute('data-is-milestone') === 'true';
                const milestoneStatus = this.getAttribute('data-milestone-status');
                const milestoneDueDate = this.getAttribute('data-due-date');

                // Build enhanced tooltip content
                let tooltipContent;
                if (isMilestone) {
                    const statusLabel = milestoneStatus === 'completed' ? 'âœ… Completed' : 'ðŸ”· Upcoming';
                    // Use data-due-date (the original due date) â€” data-end is bumped +1 for bar width
                    const displayDate = milestoneDueDate || startDate;
                    tooltipContent = `<strong>â—† ${fullName}</strong>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-diamond" style="color:#7c3aed;"></i> Milestone</div>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-circle-check"></i> ${statusLabel}</div>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-calendar"></i> ${formatDateDisplay(displayDate)}</div>`;
                } else {
                    tooltipContent = `<strong>${fullName}</strong>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-flag"></i> Priority: ${priority.charAt(0).toUpperCase() + priority.slice(1)}</div>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-user"></i> ${assignedTo}</div>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-calendar"></i> ${formatDateDisplay(startDate)} - ${formatDateDisplay(endDate)}</div>`;
                    tooltipContent += `<div class="tooltip-row"><i class="fas fa-tasks"></i> Progress: ${progress}%</div>`;
                }

                tooltip.innerHTML = tooltipContent;
                tooltip.classList.add('show');
                
                // Position tooltip on first appearance
                positionTooltip(e);
            });

            // Add mousemove event to follow cursor with smart positioning
            barWrapper.addEventListener('mousemove', function(e) {
                positionTooltip(e);
            });

            // Add mouseleave event
            barWrapper.addEventListener('mouseleave', function() {
                tooltip.classList.remove('show');
            });
        });

        // Hide tooltip when clicking anywhere
        document.addEventListener('click', function(e) {
            tooltip.classList.remove('show');
        });

        // Hide tooltip when scrolling
        const ganttContainer = document.querySelector('.gantt-container');
        if (ganttContainer) {
            ganttContainer.addEventListener('scroll', function() {
                tooltip.classList.remove('show');
            });
        }

        // Hide tooltip when mouse moves outside the Gantt chart area
        const ganttElement = document.getElementById('gantt');
        if (ganttElement) {
            ganttElement.addEventListener('mouseleave', function() {
                // Small delay to allow moving between bars
                setTimeout(function() {
                    const stillHovering = document.querySelector('.bar-wrapper:hover');
                    if (!stillHovering) {
                        tooltip.classList.remove('show');
                    }
                }, 50);
            });
        }

        // Smart tooltip positioning function - ensures tooltip is always visible
        function positionTooltip(e) {
            const tooltip = document.getElementById('gantt-tooltip');
            if (!tooltip || !tooltip.classList.contains('show')) return;

            // Get tooltip dimensions (need to make it visible first to measure)
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;

            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Offset from cursor
            const offsetX = 15;
            const offsetY = 15;

            // Determine best position: prioritize visibility
            let left, top;
            
            // Calculate space available in each direction
            const spaceRight = viewportWidth - e.clientX;
            const spaceLeft = e.clientX;
            const spaceBelow = viewportHeight - e.clientY;
            const spaceAbove = e.clientY;

            // Horizontal positioning: choose side with more space
            if (spaceRight >= tooltipWidth + offsetX) {
                // Enough space on the right
                left = e.pageX + offsetX;
            } else if (spaceLeft >= tooltipWidth + offsetX) {
                // Not enough on right, try left
                left = e.pageX - tooltipWidth - offsetX;
            } else {
                // Not enough on either side, center horizontally with margin
                left = Math.max(10, Math.min(e.pageX - tooltipWidth / 2, viewportWidth - tooltipWidth - 10));
            }

            // Vertical positioning: choose top or bottom based on available space
            if (spaceBelow >= tooltipHeight + offsetY) {
                // Enough space below cursor
                top = e.pageY + offsetY;
            } else if (spaceAbove >= tooltipHeight + offsetY) {
                // Not enough below, position above cursor
                top = e.pageY - tooltipHeight - offsetY;
            } else {
                // Not enough space above or below, position near cursor
                // Choose the side with more space
                if (spaceBelow > spaceAbove) {
                    // More space below, position at top of viewport
                    top = Math.max(10, e.pageY - tooltipHeight / 2);
                } else {
                    // More space above, position accordingly
                    top = Math.max(10, e.pageY - tooltipHeight + offsetY);
                }
            }

            // Final boundary checks to ensure tooltip stays within viewport
            left = Math.max(10, Math.min(left, viewportWidth - tooltipWidth - 10));
            top = Math.max(10, Math.min(top, viewportHeight - tooltipHeight - 10));

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
    }

    // Enhance bars with task names only (no progress, no assignments)
    function enhanceBarsWithInfo() {
        // Process both regular tasks and milestones
        const allItems = [...tasks, ...ganttMilestones];
        allItems.forEach(task => {
            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${task.id}"]`);
            if (!barWrapper) return;

            const bar = barWrapper.querySelector('.bar');
            if (!bar) return;

            // Safely get bounding box - getBBox() can throw or return invalid values
            let barRect;
            try {
                barRect = bar.getBBox();
            } catch (e) {
                console.warn(`Could not get bounding box for task ${task.id}:`, e);
                return;
            }
            
            // Validate dimensions - skip if invalid (negative or zero)
            const barWidth = barRect.width;
            const barHeight = barRect.height;
            
            if (barWidth <= 0 || barHeight <= 0 || !isFinite(barWidth) || !isFinite(barHeight)) {
                console.warn(`Invalid bar dimensions for task ${task.id}: width=${barWidth}, height=${barHeight}`);
                return;
            }

            // Calculate space reserved for assignee initials (if task has assignee and bar is wide enough)
            const hasAssignee = task.assigned_to !== 'Unassigned';
            const initialsSpace = (hasAssignee && barWidth >= 40) ? 28 : 0; // 20px circle + 8px padding

            // Find and modify the existing label to show truncated name ONLY - INSIDE the bar
            const existingLabel = barWrapper.querySelector('.bar-label');
            if (existingLabel) {
                // Adjust minimum width threshold based on view mode - more aggressive showing
                let minWidth = 20;  // Show text for bars as small as 20px
                if (currentViewMode === 'Month') {
                    minWidth = 12; // More aggressive showing in month view
                } else if (currentViewMode === 'Day') {
                    minWidth = 40; // Day view has larger bars
                }

                // Show labels for bars wider than minimum width
                if (barWidth > minWidth) {
                    // Calculate how many characters can fit - use smaller font for narrow bars
                    let charWidth = 5.5; // Tighter character width estimate
                    let fontSize = 10;
                    
                    // Adjust font size based on bar width for better readability
                    if (barWidth < 40) {
                        fontSize = 8;
                        charWidth = 4.5;
                    } else if (barWidth < 80) {
                        fontSize = 9;
                        charWidth = 5;
                    } else if (currentViewMode === 'Month') {
                        fontSize = 9;
                        charWidth = 5;
                    } else if (currentViewMode === 'Day') {
                        fontSize = 11;
                        charWidth = 6;
                    } else {
                        // Week view
                        fontSize = 10;
                        charWidth = 5.5;
                    }
                    
                    existingLabel.style.fontSize = fontSize + 'px';
                    
                    // Account for assignee initials space on the right
                    const availableWidth = barWidth - 6 - initialsSpace; // Padding + initials space
                    const maxChars = Math.floor(availableWidth / charWidth);

                    let displayName = task.fullName;
                    
                    // For very small bars, show at least initial
                    if (maxChars < 2) {
                        displayName = task.fullName.substring(0, 1);
                    } else if (maxChars < 4) {
                        displayName = task.fullName.substring(0, maxChars);
                    } else if (displayName.length > maxChars) {
                        displayName = displayName.substring(0, maxChars - 3) + '...';
                    }

                    // Update the label text and position - shift left if there's an assignee
                    existingLabel.textContent = displayName;
                    const labelX = barRect.x + (barWidth - initialsSpace) / 2;
                    existingLabel.setAttribute('x', labelX);
                    existingLabel.setAttribute('y', barRect.y + barHeight / 2);
                    existingLabel.setAttribute('text-anchor', 'middle');
                    existingLabel.setAttribute('dominant-baseline', 'middle');
                    existingLabel.style.display = 'block';
                    
                    // Remove any outside positioning classes
                    existingLabel.classList.remove('outside-left', 'outside-right');
                } else {
                    // Only hide label if bar is extremely small
                    existingLabel.textContent = '';
                    existingLabel.style.display = 'none';
                }
            }
        });
    }

    // Add assignee initials to task bars (like ClickUp)
    function addAssigneeInitials() {
        const ganttSvg = document.querySelector('#gantt');
        if (!ganttSvg) return;

        // Remove existing assignee elements to prevent duplicates
        ganttSvg.querySelectorAll('.assignee-group').forEach(el => el.remove());

        tasks.forEach(task => {
            // Skip if no assignee or is milestone
            if (task.assigned_to === 'Unassigned') return;
            if (task.isMilestone) return;

            const barWrapper = document.querySelector(`.bar-wrapper[data-id="${task.id}"]`);
            if (!barWrapper) return;

            const bar = barWrapper.querySelector('.bar');
            if (!bar) return;

            let barRect;
            try {
                barRect = bar.getBBox();
            } catch (e) {
                return;
            }

            // Only show initials if bar is wide enough (at least 40px for circle)
            if (barRect.width < 40) return;

            // Get initials from first and last name, fallback to username
            let initials = '';
            if (task.assignee_first_name && task.assignee_last_name) {
                initials = (task.assignee_first_name.charAt(0) + task.assignee_last_name.charAt(0)).toUpperCase();
            } else if (task.assignee_first_name) {
                initials = task.assignee_first_name.substring(0, 2).toUpperCase();
            } else {
                // Use first 2 chars of username
                initials = task.assigned_to.substring(0, 2).toUpperCase();
            }

            // Create SVG group for assignee avatar
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'assignee-group');

            // Position at the right side of the bar
            const circleRadius = 10;
            const circleX = barRect.x + barRect.width - circleRadius - 4;
            const circleY = barRect.y + barRect.height / 2;

            // Create circle background
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', circleX);
            circle.setAttribute('cy', circleY);
            circle.setAttribute('r', circleRadius);
            circle.setAttribute('class', 'assignee-circle');
            group.appendChild(circle);

            // Create initials text
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', circleX);
            text.setAttribute('y', circleY);
            text.setAttribute('class', 'assignee-initials');
            text.textContent = initials;
            group.appendChild(text);

            // Insert into the bar wrapper
            barWrapper.appendChild(group);
        });
    }

    // Initialize Gantt chart on page load
    document.addEventListener('DOMContentLoaded', function() {
        // If phases exist, the phase-specific handler below will initialize the chart
        // This prevents double initialization which causes the shrink/expand flash
        if (!hasPhases) {
            initGantt('Week');
        }
    });
    
    // Set up a MutationObserver to continuously remove frappe-gantt's default arrow polygons
    // as they may be re-added during user interactions (hover, scroll, etc.)
    function setupArrowPolygonObserver() {
        const ganttSvg = document.querySelector('#gantt');
        if (ganttSvg) {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.addedNodes.length) {
                        mutation.addedNodes.forEach(function(node) {
                            // If a polygon is added that isn't our custom ones, remove it
                            if (node.nodeName === 'polygon' || node.tagName === 'polygon') {
                                const isInDefs = node.closest && node.closest('defs');
                                const isCustom = node.classList && node.classList.contains('custom-arrowhead');
                                if (!isInDefs && !isCustom) {
                                    node.remove();
                                }
                            }
                            // Also check children if it's an element node
                            if (node.querySelectorAll) {
                                node.querySelectorAll('polygon').forEach(function(p) {
                                    const isInDefs = p.closest('defs');
                                    const isCustom = p.classList.contains('custom-arrowhead');
                                    if (!isInDefs && !isCustom) {
                                        p.remove();
                                    }
                                });
                            }
                        });
                    }
                });
            });
            
            observer.observe(ganttSvg, {
                childList: true,
                subtree: true
            });
        }
    }

    // Update task dates
    function updateTaskDates(taskId, start, end) {
        fetch(`/api/tasks/update-dates/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                task_id: taskId,
                start_date: formatDate(start),
                due_date: formatDate(end)
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Task dates updated successfully');
            } else {
                console.error('Failed to update task dates:', data.error);
                // Reload the page to revert changes
                location.reload();
            }
        })
        .catch(error => {
            console.error('Error updating task dates:', error);
            location.reload();
        });
    }

    // Update task progress
    function updateTaskProgress(taskId, progress) {
        fetch(`/tasks/${taskId}/update-progress/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                progress: progress
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Task progress updated successfully');
            } else {
                console.error('Failed to update task progress:', data.error);
            }
        })
        .catch(error => {
            console.error('Error updating task progress:', error);
        });
    }

    // Helper function to format date
    function formatDate(date) {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // Helper function to format date for display in tooltips
    function formatDateDisplay(dateStr) {
        if (!dateStr) return 'N/A';
        // Parse the YYYY-MM-DD string in UTC to avoid local-offset date shifts
        const d = new Date(dateStr);
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `${months[d.getUTCMonth()]} ${d.getUTCDate()}, ${d.getUTCFullYear()}`;
    }

    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // View mode buttons
    document.querySelectorAll('.view-btn').forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            this.classList.add('active');
            // Change Gantt view mode
            const mode = this.getAttribute('data-mode');
            initGantt(mode);
        });
    });
    {% endif %}

    // =====================================================
    // PHASE-BASED VIEW FUNCTIONS
    // =====================================================

    // Set view to show only phases (collapsed)
    function setPhaseView() {
        currentView = 'phases';
        expandedPhases.clear();
        updateViewButtons();
        updatePhaseInfoPanel();
        // Re-render Gantt with phase view
        if (hasPhases) {
            renderGanttWithPhases();
        }
    }

    // Set view to show all tasks
    function setAllTasksView() {
        currentView = 'all';
        updateViewButtons();
        // Re-render Gantt with all tasks
        initGantt(currentViewMode);
    }

    // Toggle a phase expansion
    function togglePhase(phaseName, event) {
        // Prevent event bubbling to avoid duplicate calls
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        
        if (expandedPhases.has(phaseName)) {
            expandedPhases.delete(phaseName);
        } else {
            expandedPhases.add(phaseName);
        }
        updatePhaseInfoPanel();
        renderGanttWithPhases();
    }

    // Update view toggle button states
    function updateViewButtons() {
        const phaseBtn = document.getElementById('phase-view-btn');
        const allTasksBtn = document.getElementById('all-tasks-btn');
        const phaseInfoPanel = document.getElementById('phase-info-panel');

        if (phaseBtn && allTasksBtn) {
            if (currentView === 'phases') {
                phaseBtn.classList.add('active');
                allTasksBtn.classList.remove('active');
                if (phaseInfoPanel) phaseInfoPanel.style.display = '';
            } else {
                phaseBtn.classList.remove('active');
                allTasksBtn.classList.add('active');
                if (phaseInfoPanel) phaseInfoPanel.style.display = 'none';
            }
        }
    }

    // Update phase info panel with current state
    function updatePhaseInfoPanel() {
        const container = document.getElementById('phase-items-container');
        if (!container || !hasPhases) return;

        let html = '';
        for (const [phaseName, data] of Object.entries(phasesData)) {
            const isExpanded = expandedPhases.has(phaseName);
            const expandIcon = isExpanded ? 'fa-chevron-down' : 'fa-chevron-right';

            html += `
                <div class="phase-item ${isExpanded ? 'expanded' : ''}" onclick="togglePhase('${phaseName}', event)">
                    <div>
                        <i class="fas ${expandIcon} me-2"></i>
                        <strong>${phaseName}</strong>
                        ${data.start && data.end ? `<small class="text-muted ms-2">${data.start} - ${data.end}</small>` : ''}
                    </div>
                    <div class="d-flex gap-2">
                        <span class="phase-badge tasks">
                            <i class="fas fa-tasks"></i> ${data.task_count || 0} tasks
                        </span>
                    </div>
                </div>
            `;
        }
        container.innerHTML = html;
    }

    // Render Gantt chart with phase-based view
    function renderGanttWithPhases() {
        if (!hasPhases) {
            initGantt(currentViewMode);
            return;
        }

        console.log('=== renderGanttWithPhases called ===');
        console.log('phasesData:', phasesData);
        console.log('numPhases:', numPhases);

        let ganttData = [];

        // Build data based on current view state
        // Iterate phases in numerical order (Phase 1, Phase 2, Phase 3...)
        for (let i = 1; i <= numPhases; i++) {
            const phaseName = `Phase ${i}`;
            const data = phasesData[phaseName];
            console.log(`Processing ${phaseName}:`, data);
            if (!data || !data.start || !data.end) {
                console.warn(`Skipping ${phaseName} - missing data or dates`);
                continue;
            }

            const phaseId = phaseName.replace(/\s+/g, '-').toLowerCase();
            const isExpanded = expandedPhases.has(phaseName);

            // Add phase bar with all required fields to match task structure
            // Calculate phase dates from actual tasks to ensure correctness
            const phaseTasks = tasks.filter(t => t.phase === phaseName && t.start && t.end && t.start !== '' && t.end !== '');
            let phaseStart = data.start;
            let phaseEnd = data.end;
            
            // If we have tasks, recalculate from them to ensure accuracy
            if (phaseTasks.length > 0) {
                const taskStarts = phaseTasks.map(t => new Date(t.start)).filter(d => !isNaN(d.getTime()));
                const taskEnds = phaseTasks.map(t => new Date(t.end)).filter(d => !isNaN(d.getTime()));
                
                if (taskStarts.length > 0) {
                    const minStart = new Date(Math.min(...taskStarts));
                    phaseStart = minStart.toISOString().split('T')[0];
                }
                if (taskEnds.length > 0) {
                    const maxEnd = new Date(Math.max(...taskEnds));
                    phaseEnd = maxEnd.toISOString().split('T')[0];
                }
            }
            
            const phaseBar = {
                id: phaseId,
                name: `${phaseName} ${isExpanded ? 'â–¼' : 'â–¶'} (${data.task_count} tasks)`,
                fullName: phaseName,
                start: phaseStart,
                end: phaseEnd,
                progress: 0,
                dependencies: '',
                custom_class: 'phase-bar',
                priority: 'phase',
                status: 'phase',
                assigned_to: '',
                assignee_first_name: '',
                assignee_last_name: '',
                item_type: 'phase',
                phase: phaseName,
                isPhase: true,
                phaseName: phaseName
            };
            console.log(`Adding phase bar for ${phaseName}:`, phaseBar);
            ganttData.push(phaseBar);

            // If expanded, add tasks and milestones for this phase
            if (isExpanded) {
                // Get phase tasks and sort by ID to maintain consistent order
                // (regardless of date changes)
                const expandedPhaseTasks = tasks
                    .filter(t => t.phase === phaseName)
                    .sort((a, b) => parseInt(a.id) - parseInt(b.id));
                
                // Process tasks
                const regularTasks = [];
                
                expandedPhaseTasks.forEach(task => {
                    // Only include tasks with valid start and end date
                    if (!task.end || task.end === 'None' || task.end === '') return;
                    if (!task.start || task.start === 'None' || task.start === '') return;
                    
                    regularTasks.push(task);
                });
                
                // Add all tasks + milestones in position-aware order for this phase
                const phaseMilestones = visibleMilestones.filter(m => m.phase === phaseName);
                buildOrderedTaskList(regularTasks, phaseMilestones).forEach(item => ganttData.push(item));
            }
        }

        // Also add unphased milestones when not using phase filter
        // (they'll just appear at end)
        visibleMilestones.filter(m => !m.phase).forEach(m => {
            if (!ganttData.find(d => d.id === m.id)) ganttData.push(m);
        });

        // If no valid phase data, fall back to all tasks view
        if (ganttData.length === 0) {
            console.warn('No valid phase data, falling back to all tasks view');
            initGantt(currentViewMode);
            return;
        }

        // IMPORTANT: Filter out dependencies that point to tasks not in current view
        // This prevents frappe-gantt errors when it tries to render arrows to non-existent tasks
        const visibleTaskIds = new Set(ganttData.map(d => d.id));
        ganttData.forEach(task => {
            if (task.dependencies) {
                // Handle both string and array dependencies
                let depList;
                if (typeof task.dependencies === 'string') {
                    depList = task.dependencies.split(',');
                } else if (Array.isArray(task.dependencies)) {
                    depList = task.dependencies;
                } else {
                    depList = [];
                }
                const validDeps = depList
                    .map(id => String(id).trim())
                    .filter(id => id && visibleTaskIds.has(id));
                task.dependencies = validDeps.join(',');
            }
        });

        // WORKAROUND: Frappe Gantt sorts by start date internally
        // To maintain phase order (1, 2, 3), we need to ensure Phase 1 starts earliest
        // Add a small visual hack: prepend phase number to ensure correct display order
        const phaseItems = ganttData.filter(d => d.isPhase);
        if (phaseItems.length > 1) {
            // Check if phases are out of order by start date
            let needsReordering = false;
            for (let i = 1; i < phaseItems.length; i++) {
                if (new Date(phaseItems[i].start) < new Date(phaseItems[i-1].start)) {
                    needsReordering = true;
                    break;
                }
            }
            
            if (needsReordering) {
                console.warn('Phases are out of chronological order - Gantt library will reorder them by start date');
                // Add phase number prefix to names for visual clarity
                phaseItems.forEach((phase, idx) => {
                    phase.name = `[${idx + 1}] ` + phase.name;
                });
            }
        }

        // Re-initialize Gantt with phase data
        // Calculate critical path - per phase if phases exist, project-wide otherwise
        // Only recalculate if not already done
        if (criticalPathTasks.size === 0) {
            criticalPathTasks = calculateProjectCriticalPath();
        }
        initGanttWithData(ganttData);
    }

    // Initialize Gantt with custom data
    function initGanttWithData(data) {
        const chartWrapper = document.getElementById('gantt-chart-wrapper');
        
        // Set body attribute for view-specific CSS styling
        document.body.setAttribute('data-view-mode', currentViewMode);
        
        // Hide chart during reconstruction to prevent visual glitch
        chartWrapper.classList.remove('chart-ready');
        
        // Clear the gantt reference
        ganttChart = null;
        
        // Completely clear the wrapper and recreate fresh SVG
        chartWrapper.innerHTML = '<svg id="gantt"></svg>';
        
        // Force a reflow to ensure DOM is updated
        void chartWrapper.offsetHeight;

        if (data.length === 0) {
            chartWrapper.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">No items to display</div>';
            chartWrapper.classList.add('chart-ready');
            return;
        }

        // Adjust bar height based on view mode for better visibility
        const barHeight = currentViewMode === 'Month' ? 40 : 32;
        const barPadding = currentViewMode === 'Month' ? 24 : 20;
        
        ganttChart = new Gantt('#gantt', data, {
            view_mode: currentViewMode,
            bar_height: barHeight,
            bar_corner_radius: 6,
            arrow_curve: 10,
            padding: barPadding,
            date_format: 'YYYY-MM-DD',
            language: 'en',
            auto_move_label: false,
            custom_popup_html: null,
            popup_trigger: 'none',
            on_click: function(task) {
                if (task.isPhase) {
                    // Don't call togglePhase here as it will be handled by the bar wrapper click
                    // Just return false to prevent default behavior
                    return false;
                } else if (task.isMilestone) {
                    const milestoneId = task.id.replace('milestone-', '');
                    const currentUrl = encodeURIComponent(window.location.href);
                    window.location.href = `/milestones/${milestoneId}/?next=${currentUrl}`;
                } else {
                    const currentUrl = encodeURIComponent(window.location.href);
                    window.location.href = `/tasks/${task.id}/?next=${currentUrl}`;
                }
            },
            on_date_change: function(task, start, end) {
                if (!task.isPhase && !task.isMilestone) {
                    updateTaskDates(task.id, start, end);
                }
            },
            on_progress_change: function(task, progress) {
                if (!task.isPhase && !task.isMilestone) {
                    updateTaskProgress(task.id, progress);
                }
            }
        });

        // Apply custom styling after render - use requestAnimationFrame for smoother rendering
        requestAnimationFrame(() => {
            applyPhaseStyling();
            
            // Show chart with smooth transition after initial styling
            requestAnimationFrame(() => {
                applyPhaseStyling();
                chartWrapper.classList.add('chart-ready');
                
                // Set up arrow polygon observer for this chart instance
                setupArrowPolygonObserver();
                
                // Additional pass for dependency arrows
                requestAnimationFrame(() => {
                    enhanceDependencyArrows();
                    
                    // Final cleanup pass
                    setTimeout(() => {
                        enhanceDependencyArrows();
                    }, 200);
                });
            });
        });
    }

    // Apply custom styling for phases
    function applyPhaseStyling() {
        const ganttSvg = document.querySelector('#gantt');
        if (!ganttSvg) return;

        // Get the current gantt data
        const currentTasks = ganttChart ? ganttChart.tasks : tasks;

        // Style phase bars
        document.querySelectorAll('.gantt .bar-wrapper').forEach(wrapper => {
            const bar = wrapper.querySelector('.bar');
            const label = wrapper.querySelector('.bar-label');
            const taskId = wrapper.getAttribute('data-id');

            if (bar && label) {
                const taskName = label.textContent || '';

                // Check if this is a phase bar
                if (taskName.includes('Phase') && taskName.includes('tasks')) {
                    bar.setAttribute('data-is-phase', 'true');
                    bar.style.cursor = 'pointer';
                }
            }
        });

        // Also apply standard styling
        applyCustomStyling();
    }

    // Initialize phase view on load if phases exist
    if (hasPhases) {
        document.addEventListener('DOMContentLoaded', function() {
            updatePhaseInfoPanel();
            if (currentView === 'phases') {
                // Start with phase view (no filters active)
                renderGanttWithPhases();
            } else {
                // Filters are active â€” show all tasks directly so matched bars are visible
                updateViewButtons();
                initGantt(currentViewMode);
            }
        });
    }

    // Handle back navigation to previous page
    function goBack() {
        // Check if there's a previous page in history
        if (document.referrer && document.referrer !== window.location.href) {
            window.history.back();
        } else {
            // Fallback to board detail if no history (demo-aware)
            {% if is_demo_mode %}
            window.location.href = '{% url "demo_board_detail" board.id %}';
            {% else %}
            window.location.href = '{% url "board_detail" board.id %}';
            {% endif %}
        }
    }

    // ============================================
    // CRITICAL PATH NETWORK FLOWCHART
    // ============================================
    
    /**
     * Generate the critical path network diagram flowchart
     */
    function generateCriticalPathFlowchart(phaseFilter = 'all') {
        const svgContainer = document.getElementById('flowchart-svg');
        const statsElement = document.getElementById('flowchart-stats');
        if (!svgContainer) return;

        // Check if tasks array exists (it's defined inside {% if tasks %})
        if (typeof tasks === 'undefined' || !Array.isArray(tasks)) {
            svgContainer.innerHTML = `
                <text x="50%" y="50%" text-anchor="middle" fill="white" font-size="18">
                    No tasks available for flowchart
                </text>
            `;
            return;
        }

        // Clear existing content
        svgContainer.innerHTML = '';

        // Get task data and filter by phase if needed
        let taskList = tasks.filter(t => 
            t.start && t.end && 
            t.start !== '' && t.end !== '' && 
            !t.name.includes('Phase') || !t.name.includes('tasks')
        );

        if (phaseFilter !== 'all') {
            taskList = taskList.filter(t => t.phase === phaseFilter);
        }

        if (taskList.length === 0) {
            svgContainer.innerHTML = `
                <text x="50%" y="50%" text-anchor="middle" fill="white" font-size="18">
                    No tasks available for flowchart
                </text>
            `;
            return;
        }

        // Build task map with dependency info and calculate critical path
        const taskMap = new Map();
        const validTaskIds = new Set(taskList.map(t => String(t.id)));

        taskList.forEach(task => {
            taskMap.set(String(task.id), {
                id: String(task.id),
                name: task.name || task.fullName,
                phase: task.phase || 'No Phase',
                start: new Date(task.start),
                end: new Date(task.end),
                // Duration: inclusive of both start and end dates (+1)
                duration: Math.max(1, Math.ceil((new Date(task.end) - new Date(task.start)) / (1000 * 60 * 60 * 24)) + 1),
                dependencies: [],
                successors: [],
                slack: 0,
                isCritical: false,
                isStart: false,
                isEnd: false
            });
        });

        // Parse dependencies
        taskList.forEach(task => {
            const taskData = taskMap.get(String(task.id));
            if (task.dependencies) {
                // Handle both string and array formats
                let depIds;
                if (typeof task.dependencies === 'string') {
                    depIds = task.dependencies.split(',')
                        .map(d => String(d).trim())
                        .filter(d => d && validTaskIds.has(d));
                } else if (Array.isArray(task.dependencies)) {
                    depIds = task.dependencies
                        .map(d => String(d).trim())
                        .filter(d => d && validTaskIds.has(d));
                } else {
                    depIds = [];
                }
                taskData.dependencies = depIds;
            }
        });

        // Build successor relationships
        taskMap.forEach((task, taskId) => {
            task.dependencies.forEach(depId => {
                const depTask = taskMap.get(depId);
                if (depTask) {
                    depTask.successors.push(taskId);
                }
            });
        });

        // Mark start and end nodes
        taskMap.forEach((task, taskId) => {
            task.isStart = task.dependencies.length === 0;
            task.isEnd = task.successors.length === 0;
        });

        // Group tasks by phase first (needed for per-phase critical path calculation)
        const phaseTasksMap = new Map();
        taskMap.forEach((task, taskId) => {
            const phase = task.phase || 'No Phase';
            if (!phaseTasksMap.has(phase)) {
                phaseTasksMap.set(phase, []);
            }
            phaseTasksMap.get(phase).push(taskId);
        });

        // Calculate critical path per phase for accurate highlighting
        // This ensures each phase shows its own critical path
        function calculateCriticalPathForTasks(taskIds) {
            if (taskIds.length === 0) return;

            const phaseTaskSet = new Set(taskIds);
            
            // Topological sort for this subset
            const visited = new Set();
            const sorted = [];
            
            function topSort(taskId) {
                if (visited.has(taskId)) return;
                visited.add(taskId);
                const task = taskMap.get(taskId);
                if (!task) return;
                // Only follow dependencies within this phase's task set
                task.dependencies.forEach(depId => {
                    if (phaseTaskSet.has(depId)) topSort(depId);
                });
                sorted.push(taskId);
            }
            taskIds.forEach(taskId => topSort(taskId));

            // Forward pass - ES and EF (relative to phase)
            sorted.forEach(taskId => {
                const task = taskMap.get(taskId);
                const phaseDeps = task.dependencies.filter(d => phaseTaskSet.has(d));
                if (phaseDeps.length === 0) {
                    task.ES = 0;
                } else {
                    task.ES = Math.max(...phaseDeps.map(depId => {
                        const dep = taskMap.get(depId);
                        return dep ? (dep.EF || 0) : 0;
                    }));
                }
                task.EF = task.ES + task.duration;
            });

            // Phase end (max EF within this phase)
            const phaseEnd = Math.max(...taskIds.map(id => taskMap.get(id).EF || 0));

            // Backward pass - LS and LF
            const reverseSorted = [...sorted].reverse();
            reverseSorted.forEach(taskId => {
                const task = taskMap.get(taskId);
                const phaseSuccs = task.successors.filter(s => phaseTaskSet.has(s));
                if (phaseSuccs.length === 0) {
                    task.LF = phaseEnd;
                } else {
                    task.LF = Math.min(...phaseSuccs.map(succId => {
                        const succ = taskMap.get(succId);
                        return succ ? (succ.LS !== null ? succ.LS : phaseEnd) : phaseEnd;
                    }));
                }
                task.LS = task.LF - task.duration;
                task.slack = Math.max(0, task.LS - task.ES); // Ensure non-negative
                task.isCritical = task.slack === 0; // Critical = zero slack
            });
        }

        // If viewing all phases, calculate critical path per phase separately
        // This ensures each phase shows its own critical path
        if (phaseFilter === 'all') {
            phaseTasksMap.forEach((taskIds, phase) => {
                calculateCriticalPathForTasks(taskIds);
            });
        } else {
            // Single phase view - calculate for all visible tasks
            calculateCriticalPathForTasks(Array.from(taskMap.keys()));
        }

        // Calculate overall project end for stats
        const projectEnd = Math.max(...Array.from(taskMap.values()).map(t => t.EF || 0));

        // Use phaseTasksMap for layout (already created above)
        const phaseGroups = phaseTasksMap;

        // Layout configuration
        const nodeWidth = 180;
        const nodeHeight = 70;
        const horizontalGap = 80;
        const verticalGap = 40;
        const phaseGap = 100;
        const padding = 50;

        // Calculate positions using layered approach per phase
        const nodePositions = new Map();
        let currentX = padding;

        // Sort phases naturally
        const sortedPhases = Array.from(phaseGroups.keys()).sort((a, b) => {
            const numA = parseInt(a.match(/\d+/)?.[0] || '0');
            const numB = parseInt(b.match(/\d+/)?.[0] || '0');
            return numA - numB;
        });

        sortedPhases.forEach((phase, phaseIndex) => {
            const phaseTasks = phaseGroups.get(phase);
            
            // Create layers based on dependencies (BFS)
            const layers = [];
            const taskToLayer = new Map();
            const remaining = new Set(phaseTasks);

            // First layer: tasks with no dependencies (within this phase)
            const firstLayer = phaseTasks.filter(taskId => {
                const task = taskMap.get(taskId);
                return task.dependencies.every(depId => !phaseTasks.includes(depId));
            });
            
            if (firstLayer.length > 0) {
                layers.push(firstLayer);
                firstLayer.forEach(taskId => {
                    taskToLayer.set(taskId, 0);
                    remaining.delete(taskId);
                });
            }

            // Subsequent layers
            while (remaining.size > 0) {
                const nextLayer = [];
                remaining.forEach(taskId => {
                    const task = taskMap.get(taskId);
                    const phaseDeps = task.dependencies.filter(depId => phaseTasks.includes(depId));
                    if (phaseDeps.every(depId => taskToLayer.has(depId))) {
                        nextLayer.push(taskId);
                    }
                });
                
                if (nextLayer.length === 0) {
                    // Handle remaining (circular or orphan)
                    remaining.forEach(taskId => nextLayer.push(taskId));
                }
                
                layers.push(nextLayer);
                nextLayer.forEach(taskId => {
                    taskToLayer.set(taskId, layers.length - 1);
                    remaining.delete(taskId);
                });
            }

            // Position tasks in this phase
            let phaseMaxX = currentX;
            layers.forEach((layer, layerIndex) => {
                const layerX = currentX + layerIndex * (nodeWidth + horizontalGap);
                layer.forEach((taskId, taskIndex) => {
                    nodePositions.set(taskId, {
                        x: layerX,
                        y: padding + taskIndex * (nodeHeight + verticalGap),
                        phase: phase,
                        phaseIndex: phaseIndex
                    });
                });
                phaseMaxX = Math.max(phaseMaxX, layerX + nodeWidth);
            });

            currentX = phaseMaxX + phaseGap;
        });

        // Calculate SVG dimensions
        const maxX = Math.max(...Array.from(nodePositions.values()).map(p => p.x)) + nodeWidth + padding;
        const maxY = Math.max(...Array.from(nodePositions.values()).map(p => p.y)) + nodeHeight + padding;

        svgContainer.setAttribute('width', maxX);
        svgContainer.setAttribute('height', maxY);
        svgContainer.setAttribute('viewBox', `0 0 ${maxX} ${maxY}`);

        // Create SVG defs with gradients and markers
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
            <linearGradient id="criticalGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#dc2626"/>
                <stop offset="100%" style="stop-color:#991b1b"/>
            </linearGradient>
            <linearGradient id="nonCriticalGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#3b82f6"/>
                <stop offset="100%" style="stop-color:#1d4ed8"/>
            </linearGradient>
            <marker id="arrowhead-fc" markerWidth="10" markerHeight="10" refX="9" refY="5" orient="auto">
                <polygon points="0 0, 10 5, 0 10" fill="#f59e0b"/>
            </marker>
            <marker id="arrowhead-fc-critical" markerWidth="10" markerHeight="10" refX="9" refY="5" orient="auto">
                <polygon points="0 0, 10 5, 0 10" fill="#ef4444"/>
            </marker>
            <filter id="glow-critical">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        `;
        svgContainer.appendChild(defs);

        // Draw phase separators and labels
        let prevPhaseMaxX = padding;
        sortedPhases.forEach((phase, phaseIndex) => {
            const phaseTasks = phaseGroups.get(phase);
            const phasePositions = phaseTasks.map(id => nodePositions.get(id));
            const phaseMinX = Math.min(...phasePositions.map(p => p.x));
            const phaseMaxX = Math.max(...phasePositions.map(p => p.x)) + nodeWidth;

            // Phase label
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', (phaseMinX + phaseMaxX) / 2);
            label.setAttribute('y', 25);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('class', 'fc-phase-label');
            label.textContent = phase;
            svgContainer.appendChild(label);

            // Phase separator line (except for first phase)
            if (phaseIndex > 0) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', phaseMinX - phaseGap / 2);
                line.setAttribute('y1', 35);
                line.setAttribute('x2', phaseMinX - phaseGap / 2);
                line.setAttribute('y2', maxY - 20);
                line.setAttribute('class', 'fc-phase-separator');
                svgContainer.appendChild(line);
            }
        });

        // Draw dependency arrows first (so they appear behind nodes)
        taskMap.forEach((task, taskId) => {
            const fromPos = nodePositions.get(taskId);
            if (!fromPos) return;

            task.successors.forEach(succId => {
                const toPos = nodePositions.get(succId);
                if (!toPos) return;

                const succTask = taskMap.get(succId);
                const isCriticalArrow = task.isCritical && succTask && succTask.isCritical;

                // Calculate arrow path (from right of source to left of target)
                const startX = fromPos.x + nodeWidth;
                const startY = fromPos.y + nodeHeight / 2;
                const endX = toPos.x;
                const endY = toPos.y + nodeHeight / 2;

                // Create curved path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (startX + endX) / 2;
                
                // Bezier curve for smoother arrows
                const d = `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`;
                
                path.setAttribute('d', d);
                path.setAttribute('class', `fc-dependency-arrow ${isCriticalArrow ? 'critical-arrow' : ''}`);
                path.setAttribute('marker-end', `url(#arrowhead-fc${isCriticalArrow ? '-critical' : ''})`);
                svgContainer.appendChild(path);
            });
        });

        // Draw task nodes
        taskMap.forEach((task, taskId) => {
            const pos = nodePositions.get(taskId);
            if (!pos) return;

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', `fc-task-node ${task.isCritical ? 'critical' : 'non-critical'} ${task.isStart ? 'start-node' : ''} ${task.isEnd ? 'end-node' : ''}`);
            g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

            // Background rect
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', nodeWidth);
            rect.setAttribute('height', nodeHeight);
            
            // Determine fill based on critical path only (simplified: red = critical, blue = non-critical)
            const fill = task.isCritical ? 'url(#criticalGradient)' : 'url(#nonCriticalGradient)';
            rect.setAttribute('fill', fill);
            if (task.isCritical) {
                rect.setAttribute('filter', 'url(#glow-critical)');
            }
            g.appendChild(rect);

            // Task title (truncated)
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', nodeWidth / 2);
            title.setAttribute('y', 20);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('class', 'fc-task-title');
            const displayName = task.name.length > 22 ? task.name.substring(0, 20) + '...' : task.name;
            title.textContent = displayName;
            g.appendChild(title);

            // Slack value
            const slackText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            slackText.setAttribute('x', nodeWidth / 2);
            slackText.setAttribute('y', 40);
            slackText.setAttribute('text-anchor', 'middle');
            slackText.setAttribute('class', 'fc-task-slack');
            slackText.textContent = task.isCritical ? 'ðŸ”¥ Slack: 0 days' : `â± Slack: ${task.slack} days`;
            g.appendChild(slackText);

            // Duration
            const durationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            durationText.setAttribute('x', nodeWidth / 2);
            durationText.setAttribute('y', 58);
            durationText.setAttribute('text-anchor', 'middle');
            durationText.setAttribute('class', 'fc-task-duration');
            durationText.textContent = `Duration: ${task.duration} days`;
            g.appendChild(durationText);

            // Click handler to navigate to task
            g.style.cursor = 'pointer';
            g.addEventListener('click', () => {
                const modal = bootstrap.Modal.getInstance(document.getElementById('criticalPathFlowchartModal'));
                if (modal) modal.hide();
                window.location.href = `/tasks/${taskId}/`;
            });

            svgContainer.appendChild(g);
        });

        // Update stats
        const criticalCount = Array.from(taskMap.values()).filter(t => t.isCritical).length;
        const totalSlack = Array.from(taskMap.values()).reduce((sum, t) => sum + t.slack, 0);
        statsElement.textContent = `${taskList.length} tasks | ${criticalCount} on critical path | Total project duration: ${projectEnd} days | Avg slack: ${(totalSlack / taskList.length).toFixed(1)} days`;

        // Populate phase selector
        const phaseSelect = document.getElementById('flowchart-phase-select');
        if (phaseSelect) {
            phaseSelect.innerHTML = '<option value="all">All Phases</option>';
            sortedPhases.forEach(phase => {
                const option = document.createElement('option');
                option.value = phase;
                option.textContent = phase;
                if (phase === phaseFilter) option.selected = true;
                phaseSelect.appendChild(option);
            });
        }
    }

    // Initialize flowchart modal
    document.addEventListener('DOMContentLoaded', function() {
        const showFlowchartBtn = document.getElementById('show-critical-path-flowchart');
        const flowchartModal = document.getElementById('criticalPathFlowchartModal');
        const phaseSelect = document.getElementById('flowchart-phase-select');
        
        if (showFlowchartBtn && flowchartModal) {
            showFlowchartBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(flowchartModal);
                modal.show();
                
                // Generate flowchart when modal opens
                setTimeout(() => {
                    generateCriticalPathFlowchart('all');
                }, 100);
            });
            
            // Re-generate on phase filter change
            if (phaseSelect) {
                phaseSelect.addEventListener('change', function() {
                    generateCriticalPathFlowchart(this.value);
                });
            }
        }

        // ============================================
        // ADD MILESTONE MODAL LOGIC
        // ============================================
        const addMilestoneBtn = document.getElementById('add-milestone-btn');
        const saveMilestoneBtn = document.getElementById('save-milestone-btn');
        const milestoneModal = document.getElementById('addMilestoneModal');

        // Populate the "Follows task" dropdown filtered to the selected phase
        function populateMilestonePositionDropdown(phase) {
            const select = document.getElementById('milestone-position-after');
            if (!select) return;
            const currentVal = select.value;
            select.innerHTML = '<option value="">\u2014 At end of phase \u2014</option>';
            const filtered = phase ? tasks.filter(t => t.phase === phase) : tasks;
            filtered.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.id;
                opt.textContent = (t.fullName || t.name).replace(/^[\u25c6\u25bc\s]+/, '');
                select.appendChild(opt);
            });
            if (currentVal) select.value = currentVal; // restore if still valid
        }

        // Wire phase change to refilter the following-task dropdown
        const milestonePhaseEl = document.getElementById('milestone-phase');
        if (milestonePhaseEl) {
            milestonePhaseEl.addEventListener('change', function() {
                populateMilestonePositionDropdown(this.value);
            });
        }

        if (addMilestoneBtn && milestoneModal) {
            addMilestoneBtn.addEventListener('click', function() {
                // Reset form
                document.getElementById('milestone-name').value = '';
                document.getElementById('milestone-description').value = '';
                if (milestonePhaseEl) milestonePhaseEl.value = '';
                populateMilestonePositionDropdown('');
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('milestone-due-date').value = today;
                document.getElementById('milestone-status').value = 'upcoming';
                const alertEl = document.getElementById('milestone-form-alert');
                if (alertEl) { alertEl.className = 'alert d-none'; alertEl.textContent = ''; }

                const modal = new bootstrap.Modal(milestoneModal);
                modal.show();
            });
        }

        if (saveMilestoneBtn) {
            saveMilestoneBtn.addEventListener('click', function() {
                const name = document.getElementById('milestone-name').value.trim();
                const description = document.getElementById('milestone-description').value.trim();
                const phaseEl = document.getElementById('milestone-phase');
                const phase = phaseEl ? phaseEl.value.trim() : '';
                const dueDate = document.getElementById('milestone-due-date').value.trim();
                const status = document.getElementById('milestone-status').value;
                const positionAfterEl = document.getElementById('milestone-position-after');
                const positionAfterTaskId = positionAfterEl ? positionAfterEl.value.trim() : '';
                const alertEl = document.getElementById('milestone-form-alert');

                if (!name) {
                    alertEl.className = 'alert alert-danger';
                    alertEl.textContent = 'Milestone name is required.';
                    return;
                }
                if (!dueDate) {
                    alertEl.className = 'alert alert-danger';
                    alertEl.textContent = 'Due date is required.';
                    return;
                }

                saveMilestoneBtn.disabled = true;
                saveMilestoneBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Saving...';

                const csrfToken = getCookie('csrftoken');
                fetch('{% url "add_gantt_milestone" board.id %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        name, description, phase, due_date: dueDate, status,
                        position_after_task_id: positionAfterTaskId || null
                    })
                })
                .then(r => r.json())
                .then(data => {
                    saveMilestoneBtn.disabled = false;
                    saveMilestoneBtn.innerHTML = '<svg width="14" height="14" style="vertical-align:middle; margin-right:4px;"><polygon points="7,1 13,7 7,13 1,7" fill="white" stroke="rgba(255,255,255,0.6)" stroke-width="1"/></svg> Save Milestone';
                    if (data.success) {
                        bootstrap.Modal.getInstance(milestoneModal).hide();
                        window.location.reload();
                    } else {
                        alertEl.className = 'alert alert-danger';
                        alertEl.textContent = data.error || 'An error occurred. Please try again.';
                    }
                })
                .catch(err => {
                    saveMilestoneBtn.disabled = false;
                    saveMilestoneBtn.innerHTML = '<svg width="14" height="14" style="vertical-align:middle; margin-right:4px;"><polygon points="7,1 13,7 7,13 1,7" fill="white" stroke="rgba(255,255,255,0.6)" stroke-width="1"/></svg> Save Milestone';
                    alertEl.className = 'alert alert-danger';
                    alertEl.textContent = 'Network error. Please try again.';
                    console.error('Milestone save error:', err);
                });
            });
        }
    });
    {% endif %}
</script>
{% endblock %}
